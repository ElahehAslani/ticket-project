import {
  __commonJS,
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/msw/node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/msw/node_modules/node-fetch/browser.js"(exports, module) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global2 !== "undefined") {
        return global2;
      }
      throw new Error("unable to locate global object");
    };
    var global2 = getGlobal();
    module.exports = exports = global2.fetch;
    if (global2.fetch) {
      exports.default = global2.fetch.bind(global2);
    }
    exports.Headers = global2.Headers;
    exports.Request = global2.Request;
    exports.Response = global2.Response;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse4(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse4(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match2) {
        return;
      }
      var n = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug2[key] = env[key];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
            if (match2 === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug2.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index2];
              match2 = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match2;
          });
          createDebug2.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug2.useColors();
        debug2.color = createDebug2.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug2.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        let i;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i = 0; i < len; i++) {
          if (!split2[i]) {
            continue;
          }
          namespaces = split2[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug2.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug2.names.map(toNamespace),
          ...createDebug2.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug2.skips.length; i < len; i++) {
          if (createDebug2.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug2.names.length; i < len; i++) {
          if (createDebug2.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/msw/lib/esm/fetch-deps.js
var statuses = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
var status = (statusCode, statusText) => {
  return (res) => {
    res.status = statusCode;
    res.statusText = statusText || statuses[String(statusCode)];
    return res;
  };
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var lib$1 = {};
var Headers = {};
var normalizeHeaderName$1 = {};
Object.defineProperty(normalizeHeaderName$1, "__esModule", { value: true });
normalizeHeaderName$1.normalizeHeaderName = void 0;
var HEADERS_INVALID_CHARACTERS = /[^a-z0-9\-#$%&'*+.^_`|~]/i;
function normalizeHeaderName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === "") {
    throw new TypeError("Invalid character in header field name");
  }
  return name.toLowerCase();
}
normalizeHeaderName$1.normalizeHeaderName = normalizeHeaderName;
var normalizeHeaderValue$1 = {};
Object.defineProperty(normalizeHeaderValue$1, "__esModule", { value: true });
normalizeHeaderValue$1.normalizeHeaderValue = void 0;
function normalizeHeaderValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
normalizeHeaderValue$1.normalizeHeaderValue = normalizeHeaderValue;
var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body2) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body2.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read$3 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __values = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(Headers, "__esModule", { value: true });
var normalizeHeaderName_1 = normalizeHeaderName$1;
var normalizeHeaderValue_1 = normalizeHeaderValue$1;
var HeadersPolyfill = function() {
  function HeadersPolyfill2(init) {
    var _this = this;
    this._headers = {};
    this._names = /* @__PURE__ */ new Map();
    if (["Headers", "HeadersPolyfill"].includes(init === null || init === void 0 ? void 0 : init.constructor.name) || init instanceof HeadersPolyfill2) {
      var initialHeaders = init;
      initialHeaders.forEach(function(value, name) {
        _this.append(name, value);
      }, this);
    } else if (Array.isArray(init)) {
      init.forEach(function(_a) {
        var _b = __read$3(_a, 2), name = _b[0], value = _b[1];
        _this.append(name, Array.isArray(value) ? value.join(", ") : value);
      });
    } else if (init) {
      Object.getOwnPropertyNames(init).forEach(function(name) {
        var value = init[name];
        _this.append(name, Array.isArray(value) ? value.join(", ") : value);
      });
    }
  }
  HeadersPolyfill2.prototype[Symbol.iterator] = function() {
    return this.entries();
  };
  HeadersPolyfill2.prototype.keys = function() {
    var _a, _b, name_1, e_1_1;
    var e_1, _c;
    return __generator(this, function(_d) {
      switch (_d.label) {
        case 0:
          _d.trys.push([0, 5, 6, 7]);
          _a = __values(Object.keys(this._headers)), _b = _a.next();
          _d.label = 1;
        case 1:
          if (!!_b.done)
            return [3, 4];
          name_1 = _b.value;
          return [4, name_1];
        case 2:
          _d.sent();
          _d.label = 3;
        case 3:
          _b = _a.next();
          return [3, 1];
        case 4:
          return [3, 7];
        case 5:
          e_1_1 = _d.sent();
          e_1 = { error: e_1_1 };
          return [3, 7];
        case 6:
          try {
            if (_b && !_b.done && (_c = _a.return))
              _c.call(_a);
          } finally {
            if (e_1)
              throw e_1.error;
          }
          return [7];
        case 7:
          return [2];
      }
    });
  };
  HeadersPolyfill2.prototype.values = function() {
    var _a, _b, value, e_2_1;
    var e_2, _c;
    return __generator(this, function(_d) {
      switch (_d.label) {
        case 0:
          _d.trys.push([0, 5, 6, 7]);
          _a = __values(Object.values(this._headers)), _b = _a.next();
          _d.label = 1;
        case 1:
          if (!!_b.done)
            return [3, 4];
          value = _b.value;
          return [4, value];
        case 2:
          _d.sent();
          _d.label = 3;
        case 3:
          _b = _a.next();
          return [3, 1];
        case 4:
          return [3, 7];
        case 5:
          e_2_1 = _d.sent();
          e_2 = { error: e_2_1 };
          return [3, 7];
        case 6:
          try {
            if (_b && !_b.done && (_c = _a.return))
              _c.call(_a);
          } finally {
            if (e_2)
              throw e_2.error;
          }
          return [7];
        case 7:
          return [2];
      }
    });
  };
  HeadersPolyfill2.prototype.entries = function() {
    var _a, _b, name_2, e_3_1;
    var e_3, _c;
    return __generator(this, function(_d) {
      switch (_d.label) {
        case 0:
          _d.trys.push([0, 5, 6, 7]);
          _a = __values(Object.keys(this._headers)), _b = _a.next();
          _d.label = 1;
        case 1:
          if (!!_b.done)
            return [3, 4];
          name_2 = _b.value;
          return [4, [name_2, this.get(name_2)]];
        case 2:
          _d.sent();
          _d.label = 3;
        case 3:
          _b = _a.next();
          return [3, 1];
        case 4:
          return [3, 7];
        case 5:
          e_3_1 = _d.sent();
          e_3 = { error: e_3_1 };
          return [3, 7];
        case 6:
          try {
            if (_b && !_b.done && (_c = _a.return))
              _c.call(_a);
          } finally {
            if (e_3)
              throw e_3.error;
          }
          return [7];
        case 7:
          return [2];
      }
    });
  };
  HeadersPolyfill2.prototype.get = function(name) {
    return this._headers[normalizeHeaderName_1.normalizeHeaderName(name)] || null;
  };
  HeadersPolyfill2.prototype.set = function(name, value) {
    var normalizedName = normalizeHeaderName_1.normalizeHeaderName(name);
    this._headers[normalizedName] = normalizeHeaderValue_1.normalizeHeaderValue(value);
    this._names.set(normalizedName, name);
  };
  HeadersPolyfill2.prototype.append = function(name, value) {
    var resolvedValue = this.has(name) ? this.get(name) + ", " + value : value;
    this.set(name, resolvedValue);
  };
  HeadersPolyfill2.prototype.delete = function(name) {
    if (!this.has(name)) {
      return this;
    }
    var normalizedName = normalizeHeaderName_1.normalizeHeaderName(name);
    delete this._headers[normalizedName];
    this._names.delete(normalizedName);
    return this;
  };
  HeadersPolyfill2.prototype.all = function() {
    return this._headers;
  };
  HeadersPolyfill2.prototype.raw = function() {
    var _this = this;
    return Object.entries(this._headers).reduce(function(headers, _a) {
      var _b = __read$3(_a, 2), name = _b[0], value = _b[1];
      headers[_this._names.get(name)] = value;
      return headers;
    }, {});
  };
  HeadersPolyfill2.prototype.has = function(name) {
    return this._headers.hasOwnProperty(normalizeHeaderName_1.normalizeHeaderName(name));
  };
  HeadersPolyfill2.prototype.forEach = function(callback, thisArg) {
    for (var name_3 in this._headers) {
      if (this._headers.hasOwnProperty(name_3)) {
        callback.call(thisArg, this._headers[name_3], name_3, this);
      }
    }
  };
  return HeadersPolyfill2;
}();
Headers.default = HeadersPolyfill;
var headersToString$1 = {};
var headersToList$1 = {};
Object.defineProperty(headersToList$1, "__esModule", { value: true });
headersToList$1.headersToList = void 0;
function headersToList(headers) {
  var headersList = [];
  headers.forEach(function(value, name) {
    var resolvedValue = value.includes(",") ? value.split(",").map(function(value2) {
      return value2.trim();
    }) : value;
    headersList.push([name, resolvedValue]);
  });
  return headersList;
}
headersToList$1.headersToList = headersToList;
var __read$2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
Object.defineProperty(headersToString$1, "__esModule", { value: true });
headersToString$1.headersToString = void 0;
var headersToList_1 = headersToList$1;
function headersToString(headers) {
  var list = headersToList_1.headersToList(headers);
  var lines = list.map(function(_a) {
    var _b = __read$2(_a, 2), name = _b[0], value = _b[1];
    var values = [].concat(value);
    return name + ": " + values.join(", ");
  });
  return lines.join("\r\n");
}
headersToString$1.headersToString = headersToString;
var headersToObject$1 = {};
Object.defineProperty(headersToObject$1, "__esModule", { value: true });
headersToObject$1.headersToObject = void 0;
var singleValueHeaders = ["user-agent"];
function headersToObject(headers) {
  var headersObject = {};
  headers.forEach(function(value, name) {
    var isMultiValue = !singleValueHeaders.includes(name.toLowerCase()) && value.includes(",");
    headersObject[name] = isMultiValue ? value.split(",").map(function(s) {
      return s.trim();
    }) : value;
  });
  return headersObject;
}
headersToObject$1.headersToObject = headersToObject;
var stringToHeaders$1 = {};
Object.defineProperty(stringToHeaders$1, "__esModule", { value: true });
stringToHeaders$1.stringToHeaders = void 0;
var Headers_1$2 = Headers;
function stringToHeaders(str) {
  var lines = str.trim().split(/[\r\n]+/);
  return lines.reduce(function(headers, line) {
    var parts = line.split(": ");
    var name = parts.shift();
    var value = parts.join(": ");
    headers.append(name, value);
    return headers;
  }, new Headers_1$2.default());
}
stringToHeaders$1.stringToHeaders = stringToHeaders;
var listToHeaders$1 = {};
var __read$1 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
Object.defineProperty(listToHeaders$1, "__esModule", { value: true });
listToHeaders$1.listToHeaders = void 0;
var Headers_1$1 = Headers;
function listToHeaders(list) {
  var headers = new Headers_1$1.default();
  list.forEach(function(_a) {
    var _b = __read$1(_a, 2), name = _b[0], value = _b[1];
    var values = [].concat(value);
    values.forEach(function(value2) {
      headers.append(name, value2);
    });
  });
  return headers;
}
listToHeaders$1.listToHeaders = listToHeaders;
var objectToHeaders$1 = {};
var reduceHeadersObject$1 = {};
Object.defineProperty(reduceHeadersObject$1, "__esModule", { value: true });
reduceHeadersObject$1.reduceHeadersObject = void 0;
function reduceHeadersObject(headers, reducer, initialState) {
  return Object.keys(headers).reduce(function(nextHeaders, name) {
    return reducer(nextHeaders, name, headers[name]);
  }, initialState);
}
reduceHeadersObject$1.reduceHeadersObject = reduceHeadersObject;
Object.defineProperty(objectToHeaders$1, "__esModule", { value: true });
objectToHeaders$1.objectToHeaders = void 0;
var Headers_1 = Headers;
var reduceHeadersObject_1$1 = reduceHeadersObject$1;
function objectToHeaders(headersObject) {
  return reduceHeadersObject_1$1.reduceHeadersObject(headersObject, function(headers, name, value) {
    var values = [].concat(value).filter(Boolean);
    values.forEach(function(value2) {
      headers.append(name, value2);
    });
    return headers;
  }, new Headers_1.default());
}
objectToHeaders$1.objectToHeaders = objectToHeaders;
var flattenHeadersList$1 = {};
var __read = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
Object.defineProperty(flattenHeadersList$1, "__esModule", { value: true });
flattenHeadersList$1.flattenHeadersList = void 0;
function flattenHeadersList(list) {
  return list.map(function(_a) {
    var _b = __read(_a, 2), name = _b[0], values = _b[1];
    return [name, [].concat(values).join("; ")];
  });
}
flattenHeadersList$1.flattenHeadersList = flattenHeadersList;
var flattenHeadersObject$1 = {};
Object.defineProperty(flattenHeadersObject$1, "__esModule", { value: true });
flattenHeadersObject$1.flattenHeadersObject = void 0;
var reduceHeadersObject_1 = reduceHeadersObject$1;
function flattenHeadersObject(headersObject) {
  return reduceHeadersObject_1.reduceHeadersObject(headersObject, function(headers, name, value) {
    headers[name] = [].concat(value).join("; ");
    return headers;
  }, {});
}
flattenHeadersObject$1.flattenHeadersObject = flattenHeadersObject;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flattenHeadersObject = exports.flattenHeadersList = exports.reduceHeadersObject = exports.objectToHeaders = exports.listToHeaders = exports.stringToHeaders = exports.headersToObject = exports.headersToList = exports.headersToString = exports.Headers = void 0;
  var Headers_12 = Headers;
  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {
    return Headers_12.default;
  } });
  var headersToString_1 = headersToString$1;
  Object.defineProperty(exports, "headersToString", { enumerable: true, get: function() {
    return headersToString_1.headersToString;
  } });
  var headersToList_12 = headersToList$1;
  Object.defineProperty(exports, "headersToList", { enumerable: true, get: function() {
    return headersToList_12.headersToList;
  } });
  var headersToObject_1 = headersToObject$1;
  Object.defineProperty(exports, "headersToObject", { enumerable: true, get: function() {
    return headersToObject_1.headersToObject;
  } });
  var stringToHeaders_1 = stringToHeaders$1;
  Object.defineProperty(exports, "stringToHeaders", { enumerable: true, get: function() {
    return stringToHeaders_1.stringToHeaders;
  } });
  var listToHeaders_1 = listToHeaders$1;
  Object.defineProperty(exports, "listToHeaders", { enumerable: true, get: function() {
    return listToHeaders_1.listToHeaders;
  } });
  var objectToHeaders_1 = objectToHeaders$1;
  Object.defineProperty(exports, "objectToHeaders", { enumerable: true, get: function() {
    return objectToHeaders_1.objectToHeaders;
  } });
  var reduceHeadersObject_12 = reduceHeadersObject$1;
  Object.defineProperty(exports, "reduceHeadersObject", { enumerable: true, get: function() {
    return reduceHeadersObject_12.reduceHeadersObject;
  } });
  var flattenHeadersList_1 = flattenHeadersList$1;
  Object.defineProperty(exports, "flattenHeadersList", { enumerable: true, get: function() {
    return flattenHeadersList_1.flattenHeadersList;
  } });
  var flattenHeadersObject_1 = flattenHeadersObject$1;
  Object.defineProperty(exports, "flattenHeadersObject", { enumerable: true, get: function() {
    return flattenHeadersObject_1.flattenHeadersObject;
  } });
})(lib$1);
function set(...args) {
  return (res) => {
    const [name, value] = args;
    if (typeof name === "string") {
      res.headers.append(name, value);
    } else {
      const headers = lib$1.objectToHeaders(name);
      headers.forEach((value2, name2) => {
        res.headers.append(name2, value2);
      });
    }
    return res;
  };
}
var parse_1 = parse;
var serialize_1 = serialize;
var decode = decodeURIComponent;
var encode = encodeURIComponent;
var pairSplitRegExp = /; */;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var pairs = str.split(pairSplitRegExp);
  var dec = opt.decode || decode;
  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var eq_idx = pair.indexOf("=");
    if (eq_idx < 0) {
      continue;
    }
    var key = pair.substr(0, eq_idx).trim();
    var val = pair.substr(++eq_idx, pair.length).trim();
    if ('"' == val[0]) {
      val = val.slice(1, -1);
    }
    if (void 0 == obj[key]) {
      obj[key] = tryDecode(val, dec);
    }
  }
  return obj;
}
function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e) {
    return str;
  }
}
var cookie = (name, value, options) => {
  return (res) => {
    const serializedCookie = serialize_1(name, value, options);
    res.headers.set("Set-Cookie", serializedCookie);
    if (typeof document !== "undefined") {
      document.cookie = serializedCookie;
    }
    return res;
  };
};
function jsonParse(str) {
  try {
    return JSON.parse(str);
  } catch (error2) {
    return void 0;
  }
}
var json = (body2) => {
  return (res) => {
    res.headers.set("Content-Type", "application/json");
    res.body = JSON.stringify(body2);
    return res;
  };
};
var lib = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    factory(exports);
  })(commonjsGlobal, function(exports2) {
    function isNodeProcess() {
      if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
        return true;
      }
      return !!(typeof process !== "undefined" && process.versions && process.versions.node);
    }
    exports2.isNodeProcess = isNodeProcess;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(lib, lib.exports);
var SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;
var MIN_SERVER_RESPONSE_TIME = 100;
var MAX_SERVER_RESPONSE_TIME = 400;
var NODE_SERVER_RESPONSE_TIME = 5;
var getRandomServerResponseTime = () => {
  if (lib.exports.isNodeProcess()) {
    return NODE_SERVER_RESPONSE_TIME;
  }
  return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME);
};
var delay = (durationOrMode) => {
  return (res) => {
    let delayTime;
    if (typeof durationOrMode === "string") {
      switch (durationOrMode) {
        case "infinite": {
          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;
          break;
        }
        case "real": {
          delayTime = getRandomServerResponseTime();
          break;
        }
        default: {
          throw new Error(`Failed to delay a response: unknown delay mode "${durationOrMode}". Please make sure you provide one of the supported modes ("real", "infinite") or a number to "ctx.delay".`);
        }
      }
    } else if (typeof durationOrMode === "undefined") {
      delayTime = getRandomServerResponseTime();
    } else {
      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {
        throw new Error(`Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for "setTimeout" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the "infinite" delay mode to delay the response indefinitely.`);
      }
      delayTime = durationOrMode;
    }
    res.delay = delayTime;
    return res;
  };
};
var useFetch = lib.exports.isNodeProcess() ? require_browser() : window.fetch;
var augmentRequestInit = (requestInit) => {
  const headers = new lib$1.Headers(requestInit.headers);
  headers.set("x-msw-bypass", "true");
  return Object.assign(Object.assign({}, requestInit), { headers: headers.all() });
};
var createFetchRequestParameters = (input) => {
  const { body: body2, method } = input;
  const requestParameters = Object.assign(Object.assign({}, input), { body: void 0 });
  if (["GET", "HEAD"].includes(method)) {
    return requestParameters;
  }
  requestParameters.body = typeof body2 === "object" ? JSON.stringify(body2) : body2;
  return requestParameters;
};
var fetch2 = (input, requestInit = {}) => {
  if (typeof input === "string") {
    return useFetch(input, augmentRequestInit(requestInit));
  }
  const requestParameters = createFetchRequestParameters(input);
  const derivedRequestInit = augmentRequestInit(requestParameters);
  return useFetch(input.url.href, derivedRequestInit);
};

// node_modules/msw/lib/esm/xml-deps.js
var body = (value) => {
  return (res) => {
    res.body = value;
    return res;
  };
};
var text = (body2) => {
  return (res) => {
    res.headers.set("Content-Type", "text/plain");
    res.body = body2;
    return res;
  };
};
var xml = (body2) => {
  return (res) => {
    res.headers.set("Content-Type", "text/xml");
    res.body = body2;
    return res;
  };
};

// node_modules/msw/lib/esm/errors-deps.js
function isObject(value) {
  return value != null && typeof value === "object" && !Array.isArray(value);
}
function mergeRight(left, right) {
  return Object.entries(right).reduce((result, [key, rightValue]) => {
    const leftValue = result[key];
    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {
      result[key] = leftValue.concat(rightValue);
      return result;
    }
    if (isObject(leftValue) && isObject(rightValue)) {
      result[key] = mergeRight(leftValue, rightValue);
      return result;
    }
    result[key] = rightValue;
    return result;
  }, Object.assign({}, left));
}
var data = (payload) => {
  return (res) => {
    const prevBody = jsonParse(res.body) || {};
    const nextBody = mergeRight(prevBody, { data: payload });
    return json(nextBody)(res);
  };
};
var errors = (errorsList) => {
  return (res) => {
    if (errorsList == null) {
      return res;
    }
    const prevBody = jsonParse(res.body) || {};
    const nextBody = mergeRight(prevBody, { errors: errorsList });
    return json(nextBody)(res);
  };
};

// node_modules/msw/lib/esm/index-deps.js
var index = Object.freeze({
  __proto__: null,
  status,
  set,
  cookie,
  body,
  data,
  delay,
  errors,
  fetch: fetch2,
  json,
  text,
  xml
});

// node_modules/msw/lib/esm/RequestHandler-deps.js
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var lib2 = {};
var invariant$1 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
format$1.format = void 0;
var POSITIONALS_EXP = /(%?)(%([sdjo]))/g;
function serializePositional(positional, flag) {
  switch (flag) {
    case "s":
      return positional;
    case "d":
    case "i":
      return Number(positional);
    case "j":
      return JSON.stringify(positional);
    case "o": {
      if (typeof positional === "string") {
        return positional;
      }
      var json2 = JSON.stringify(positional);
      if (json2 === "{}" || json2 === "[]" || /^\[object .+?\]$/.test(json2)) {
        return positional;
      }
      return json2;
    }
  }
}
function format(message) {
  var positionals = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positionals[_i - 1] = arguments[_i];
  }
  if (positionals.length === 0) {
    return message;
  }
  var positionalIndex = 0;
  var formattedMessage = message.replace(POSITIONALS_EXP, function(match2, isEscaped, _, flag) {
    var positional = positionals[positionalIndex];
    var value = serializePositional(positional, flag);
    if (!isEscaped) {
      positionalIndex++;
      return value;
    }
    return match2;
  });
  if (positionalIndex < positionals.length) {
    formattedMessage += " " + positionals.slice(positionalIndex).join(" ");
  }
  formattedMessage = formattedMessage.replace(/%{2,2}/g, "%");
  return formattedMessage;
}
format$1.format = format;
var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
    to[j] = from[i];
  return to;
};
Object.defineProperty(invariant$1, "__esModule", { value: true });
invariant$1.invariant = invariant$1.InvariantError = void 0;
var format_1 = format$1;
var STACK_FRAMES_TO_IGNORE = 2;
var InvariantError = function(_super) {
  __extends(InvariantError2, _super);
  function InvariantError2(message) {
    var positionals = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      positionals[_i - 1] = arguments[_i];
    }
    var _this = _super.call(this, message) || this;
    _this.name = "Invariant Violation";
    _this.message = format_1.format.apply(void 0, __spreadArray([message], positionals));
    if (_this.stack) {
      var prevStack = _this.stack;
      _this.stack = prevStack.split("\n").slice(STACK_FRAMES_TO_IGNORE).join("\n");
    }
    return _this;
  }
  return InvariantError2;
}(Error);
invariant$1.InvariantError = InvariantError;
function invariant(predicate, message) {
  var positionals = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    positionals[_i - 2] = arguments[_i];
  }
  if (!predicate) {
    throw new (InvariantError.bind.apply(InvariantError, __spreadArray([void 0, message], positionals)))();
  }
}
invariant$1.invariant = invariant;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(invariant$1, exports);
  __exportStar(format$1, exports);
})(lib2);
var LIBRARY_PREFIX = "[MSW]";
function formatMessage(message, ...positionals) {
  const interpolatedMessage = lib2.format(message, ...positionals);
  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;
}
function warn(message, ...positionals) {
  console.warn(formatMessage(message, ...positionals));
}
function error(message, ...positionals) {
  console.error(formatMessage(message, ...positionals));
}
var devUtils = {
  formatMessage,
  warn,
  error
};
var NetworkError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NetworkError";
  }
};
function parseContentHeaders(headersString) {
  var _a, _b;
  const headers = lib$1.stringToHeaders(headersString);
  const contentType = headers.get("content-type") || "text/plain";
  const disposition = headers.get("content-disposition");
  if (!disposition) {
    throw new Error('"Content-Disposition" header is required.');
  }
  const directives = disposition.split(";").reduce((acc, chunk) => {
    const [name2, ...rest2] = chunk.trim().split("=");
    acc[name2] = rest2.join("=");
    return acc;
  }, {});
  const name = (_a = directives.name) === null || _a === void 0 ? void 0 : _a.slice(1, -1);
  const filename = (_b = directives.filename) === null || _b === void 0 ? void 0 : _b.slice(1, -1);
  return {
    name,
    filename,
    contentType
  };
}
function parseMultipartData(data2, headers) {
  const contentType = headers === null || headers === void 0 ? void 0 : headers.get("content-type");
  if (!contentType) {
    return void 0;
  }
  const [, ...directives] = contentType.split(/; */);
  const boundary = directives.filter((d) => d.startsWith("boundary=")).map((s) => s.replace(/^boundary=/, ""))[0];
  if (!boundary) {
    return void 0;
  }
  const boundaryRegExp = new RegExp(`--+${boundary}`);
  const fields = data2.split(boundaryRegExp).filter((chunk) => chunk.startsWith("\r\n") && chunk.endsWith("\r\n")).map((chunk) => chunk.trimStart().replace(/\r\n$/, ""));
  if (!fields.length) {
    return void 0;
  }
  const parsedBody = {};
  try {
    for (const field of fields) {
      const [contentHeaders, ...rest2] = field.split("\r\n\r\n");
      const contentBody = rest2.join("\r\n\r\n");
      const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);
      const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });
      const parsedValue = parsedBody[name];
      if (parsedValue === void 0) {
        parsedBody[name] = value;
      } else if (Array.isArray(parsedValue)) {
        parsedBody[name] = [...parsedValue, value];
      } else {
        parsedBody[name] = [parsedValue, value];
      }
    }
    return parsedBody;
  } catch (error2) {
    return void 0;
  }
}
function parseBody(body2, headers) {
  if (!body2) {
    return body2;
  }
  const contentType = headers === null || headers === void 0 ? void 0 : headers.get("content-type");
  const hasMultipartContent = contentType === null || contentType === void 0 ? void 0 : contentType.startsWith("multipart/form-data");
  if (hasMultipartContent && typeof body2 !== "object") {
    return parseMultipartData(body2, headers) || body2;
  }
  const hasJsonContent = contentType === null || contentType === void 0 ? void 0 : contentType.includes("json");
  if (hasJsonContent && typeof body2 !== "object") {
    return jsonParse(body2) || body2;
  }
  return body2;
}
var getPublicUrlFromRequest = (request) => {
  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(request.url.pathname, `${request.url.protocol}//${request.url.host}`).href;
};
var StatusCodeColor;
(function(StatusCodeColor2) {
  StatusCodeColor2["Success"] = "#69AB32";
  StatusCodeColor2["Warning"] = "#F0BB4B";
  StatusCodeColor2["Danger"] = "#E95F5D";
})(StatusCodeColor || (StatusCodeColor = {}));
function getStatusCodeColor(status2) {
  if (status2 < 300) {
    return StatusCodeColor.Success;
  }
  if (status2 < 400) {
    return StatusCodeColor.Warning;
  }
  return StatusCodeColor.Danger;
}
function getTimestamp() {
  const now = new Date();
  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map((chunk) => chunk.slice(0, 2)).map((chunk) => chunk.padStart(2, "0")).join(":");
}
function prepareRequest(request) {
  return Object.assign(Object.assign({}, request), { headers: request.headers.all() });
}
function prepareResponse(res) {
  const responseHeaders = lib$1.objectToHeaders(res.headers);
  return Object.assign(Object.assign({}, res), {
    body: parseBody(res.body, responseHeaders)
  });
}
var pathToRegExp = (path) => {
  const pattern = path.replace(/\./g, "\\.").replace(/\//g, "/").replace(/\?/g, "\\?").replace(/\/+$/, "").replace(/\*+/g, ".*").replace(/:([^\d|^\/][a-zA-Z0-9_]*(?=(?:\/|\\.)|$))/g, (_, paramName) => `(?<${paramName}>[^/]+?)`).concat("(\\/|$)");
  return new RegExp(pattern, "gi");
};
var match = (path, url) => {
  const expression = path instanceof RegExp ? path : pathToRegExp(path);
  const match2 = expression.exec(url) || false;
  const matches = path instanceof RegExp ? !!match2 : !!match2 && match2[0] === match2.input;
  return {
    matches,
    params: match2 && matches ? match2.groups || null : null
  };
};
var getCleanUrl$1 = {};
Object.defineProperty(getCleanUrl$1, "__esModule", { value: true });
var getCleanUrl_2 = getCleanUrl$1.getCleanUrl = void 0;
function getCleanUrl(url, isAbsolute) {
  if (isAbsolute === void 0) {
    isAbsolute = true;
  }
  return [isAbsolute && url.origin, url.pathname].filter(Boolean).join("");
}
getCleanUrl_2 = getCleanUrl$1.getCleanUrl = getCleanUrl;
var REDUNDANT_CHARACTERS_EXP = /[\?|#].*$/g;
function getSearchParams(path) {
  return new URL(`/${path}`, "http://localhost").searchParams;
}
function cleanUrl(path) {
  return path.replace(REDUNDANT_CHARACTERS_EXP, "");
}
function getAbsoluteUrl(path, baseUrl) {
  if (!path.startsWith("/")) {
    return path;
  }
  const origin = baseUrl || typeof location !== "undefined" && location.origin;
  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;
}
function normalizePath(path, baseUrl) {
  if (path instanceof RegExp) {
    return path;
  }
  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);
  return cleanUrl(maybeAbsoluteUrl);
}
function matchRequestUrl(url, path, baseUrl) {
  const normalizedPath = normalizePath(path, baseUrl);
  return match(normalizedPath, getCleanUrl_2(url));
}
function compose(...fns) {
  return (...args) => {
    return fns.reduceRight((leftFn, rightFn) => {
      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);
    }, args[0]);
  };
}
var defaultResponse = {
  status: 200,
  statusText: "OK",
  body: null,
  delay: 0,
  once: false
};
var defaultResponseTransformers = [];
function createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {
  return (...transformers) => __awaiter(this, void 0, void 0, function* () {
    const initialResponse = Object.assign({}, defaultResponse, {
      headers: new lib$1.Headers({
        "x-powered-by": "msw"
      })
    }, responseOverrides);
    const resolvedTransformers = [
      ...defaultTransformers,
      ...transformers
    ].filter(Boolean);
    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;
    return resolvedResponse;
  });
}
var response = Object.assign(createResponseComposition(), {
  once: createResponseComposition({ once: true }),
  networkError(message) {
    throw new NetworkError(message);
  }
});
function getCallFrame() {
  const stack = new Error().stack || "";
  const frames = stack.split("\n");
  const ignoreFrameRegExp = /(node_modules)?[\/\\]lib[\/\\](umd|esm|iief|cjs)[\/\\]|^[^\/\\]*$/;
  const declarationFrame = frames.slice(1).find((frame) => {
    return !ignoreFrameRegExp.test(frame);
  });
  if (!declarationFrame) {
    return;
  }
  const declarationPath = declarationFrame.replace(/\s*at [^()]*\(([^)]+)\)/, "$1").replace(/^@/, "");
  return declarationPath;
}
function isIterable(fn) {
  if (!fn) {
    return false;
  }
  return typeof fn[Symbol.iterator] == "function";
}
var defaultContext = {
  status,
  set,
  delay,
  fetch: fetch2
};
var RequestHandler = class {
  constructor(options) {
    this.shouldSkip = false;
    this.ctx = options.ctx || defaultContext;
    this.resolver = options.resolver;
    const callFrame = getCallFrame();
    this.info = Object.assign(Object.assign({}, options.info), { callFrame });
  }
  parse(_request, _resolutionContext) {
    return null;
  }
  test(request, resolutionContext) {
    return this.predicate(request, this.parse(request, resolutionContext), resolutionContext);
  }
  getPublicRequest(request, _parsedResult) {
    return request;
  }
  markAsSkipped(shouldSkip = true) {
    this.shouldSkip = shouldSkip;
  }
  run(request, resolutionContext) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.shouldSkip) {
        return null;
      }
      const parsedResult = this.parse(request, resolutionContext);
      const shouldIntercept = this.predicate(request, parsedResult, resolutionContext);
      if (!shouldIntercept) {
        return null;
      }
      const publicRequest = this.getPublicRequest(request, parsedResult);
      const executeResolver = this.wrapResolver(this.resolver);
      const mockedResponse = yield executeResolver(publicRequest, response, this.ctx);
      return this.createExecutionResult(parsedResult, publicRequest, mockedResponse);
    });
  }
  wrapResolver(resolver) {
    return (req, res, ctx) => __awaiter(this, void 0, void 0, function* () {
      const result = this.resolverGenerator || (yield resolver(req, res, ctx));
      if (isIterable(result)) {
        const { value, done } = result[Symbol.iterator]().next();
        const nextResponse = yield value;
        if (!nextResponse && done) {
          return this.resolverGeneratorResult;
        }
        if (!this.resolverGenerator) {
          this.resolverGenerator = result;
        }
        this.resolverGeneratorResult = nextResponse;
        return nextResponse;
      }
      return result;
    });
  }
  createExecutionResult(parsedResult, request, response2) {
    return {
      handler: this,
      parsedResult: parsedResult || null,
      request,
      response: response2 || null
    };
  }
};

// node_modules/msw/lib/esm/rest-deps.js
function isStringEqual(actual, expected) {
  return actual.toLowerCase() === expected.toLowerCase();
}
var RESTMethods;
(function(RESTMethods2) {
  RESTMethods2["HEAD"] = "HEAD";
  RESTMethods2["GET"] = "GET";
  RESTMethods2["POST"] = "POST";
  RESTMethods2["PUT"] = "PUT";
  RESTMethods2["PATCH"] = "PATCH";
  RESTMethods2["OPTIONS"] = "OPTIONS";
  RESTMethods2["DELETE"] = "DELETE";
})(RESTMethods || (RESTMethods = {}));
var restContext = {
  set,
  status,
  cookie,
  body,
  text,
  json,
  xml,
  delay,
  fetch: fetch2
};
var RestHandler = class extends RequestHandler {
  constructor(method, path, resolver) {
    super({
      info: {
        header: `${method} ${path}`,
        path,
        method
      },
      ctx: restContext,
      resolver
    });
    this.checkRedundantQueryParameters();
  }
  checkRedundantQueryParameters() {
    const { method, path } = this.info;
    if (path instanceof RegExp) {
      return;
    }
    const url = cleanUrl(path);
    if (url === path) {
      return;
    }
    const searchParams = getSearchParams(path);
    const queryParams = [];
    searchParams.forEach((_, paramName) => {
      queryParams.push(paramName);
    });
    devUtils.warn(`Found a redundant usage of query parameters in the request handler URL for "${method} ${path}". Please match against a path instead, and access query parameters in the response resolver function:

rest.${method.toLowerCase()}("${url}", (req, res, ctx) => {
  const query = req.url.searchParams
${queryParams.map((paramName) => `  const ${paramName} = query.get("${paramName}")`).join("\n")}
})      `);
  }
  parse(request, resolutionContext) {
    return matchRequestUrl(request.url, this.info.path, resolutionContext === null || resolutionContext === void 0 ? void 0 : resolutionContext.baseUrl);
  }
  getPublicRequest(request, parsedResult) {
    return Object.assign(Object.assign({}, request), { params: parsedResult.params || {} });
  }
  predicate(request, parsedResult) {
    return isStringEqual(this.info.method, request.method) && parsedResult.matches;
  }
  log(request, response2) {
    const publicUrl = getPublicUrlFromRequest(request);
    const loggedRequest = prepareRequest(request);
    const loggedResponse = prepareResponse(response2);
    const statusColor = getStatusCodeColor(response2.status);
    console.groupCollapsed(devUtils.formatMessage("%s %s %s (%c%s%c)"), getTimestamp(), request.method, publicUrl, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, "color:inherit");
    console.log("Request", loggedRequest);
    console.log("Handler:", {
      mask: this.info.path,
      resolver: this.resolver
    });
    console.log("Response", loggedResponse);
    console.groupEnd();
  }
};
function createRestHandler(method) {
  return (path, resolver) => {
    return new RestHandler(method, path, resolver);
  };
}
var rest = {
  head: createRestHandler(RESTMethods.HEAD),
  get: createRestHandler(RESTMethods.GET),
  post: createRestHandler(RESTMethods.POST),
  put: createRestHandler(RESTMethods.PUT),
  delete: createRestHandler(RESTMethods.DELETE),
  patch: createRestHandler(RESTMethods.PATCH),
  options: createRestHandler(RESTMethods.OPTIONS)
};

// node_modules/msw/lib/esm/graphql-deps.js
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function isObjectLike(value) {
  return _typeof$3(value) == "object" && value !== null;
}
var SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
function getLocation(source, position2) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position2 + 1;
  var match2;
  while ((match2 = lineRegexp.exec(source.body)) && match2.index < position2) {
    line += 1;
    column = position2 + 1 - (match2.index + match2[0].length);
  }
  return {
    line,
    column
  };
}
function printLocation(location2) {
  return printSourceLocation(location2.source, getLocation(location2.source, location2.start));
}
function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body2 = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body2.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    var subLineIndex = Math.floor(columnNum / 80);
    var subLineColumnNum = columnNum % 80;
    var subLines = [];
    for (var i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
      return ["", subLine];
    }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
  }
  return locationStr + printPrefixedLines([
    ["".concat(lineNum - 1), lines[lineIndex - 1]],
    ["".concat(lineNum), locationLine],
    ["", whitespace(columnNum - 1) + "^"],
    ["".concat(lineNum + 1), lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  var existingLines = lines.filter(function(_ref) {
    _ref[0];
    var line = _ref[1];
    return line !== void 0;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
    var prefix = _ref2[0];
    return prefix.length;
  }));
  return existingLines.map(function(_ref3) {
    var prefix = _ref3[0], line = _ref3[1];
    return leftPad(padLen, prefix) + (line ? " | " + line : " |");
  }).join("\n");
}
function whitespace(len) {
  return Array(len + 1).join(" ");
}
function leftPad(len, str) {
  return whitespace(len - str.length) + str;
}
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var GraphQLError = function(_Error) {
  _inherits(GraphQLError2, _Error);
  var _super = _createSuper(GraphQLError2);
  function GraphQLError2(message, nodes, source, positions, path, originalError, extensions) {
    var _locations2, _source2, _positions2, _extensions2;
    var _this;
    _classCallCheck(this, GraphQLError2);
    _this = _super.call(this, message);
    var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : void 0 : nodes ? [nodes] : void 0;
    var _source = source;
    if (!_source && _nodes) {
      var _nodes$0$loc;
      _source = (_nodes$0$loc = _nodes[0].loc) === null || _nodes$0$loc === void 0 ? void 0 : _nodes$0$loc.source;
    }
    var _positions = positions;
    if (!_positions && _nodes) {
      _positions = _nodes.reduce(function(list, node) {
        if (node.loc) {
          list.push(node.loc.start);
        }
        return list;
      }, []);
    }
    if (_positions && _positions.length === 0) {
      _positions = void 0;
    }
    var _locations;
    if (positions && source) {
      _locations = positions.map(function(pos) {
        return getLocation(source, pos);
      });
    } else if (_nodes) {
      _locations = _nodes.reduce(function(list, node) {
        if (node.loc) {
          list.push(getLocation(node.loc.source, node.loc.start));
        }
        return list;
      }, []);
    }
    var _extensions = extensions;
    if (_extensions == null && originalError != null) {
      var originalExtensions = originalError.extensions;
      if (isObjectLike(originalExtensions)) {
        _extensions = originalExtensions;
      }
    }
    Object.defineProperties(_assertThisInitialized(_this), {
      name: {
        value: "GraphQLError"
      },
      message: {
        value: message,
        enumerable: true,
        writable: true
      },
      locations: {
        value: (_locations2 = _locations) !== null && _locations2 !== void 0 ? _locations2 : void 0,
        enumerable: _locations != null
      },
      path: {
        value: path !== null && path !== void 0 ? path : void 0,
        enumerable: path != null
      },
      nodes: {
        value: _nodes !== null && _nodes !== void 0 ? _nodes : void 0
      },
      source: {
        value: (_source2 = _source) !== null && _source2 !== void 0 ? _source2 : void 0
      },
      positions: {
        value: (_positions2 = _positions) !== null && _positions2 !== void 0 ? _positions2 : void 0
      },
      originalError: {
        value: originalError
      },
      extensions: {
        value: (_extensions2 = _extensions) !== null && _extensions2 !== void 0 ? _extensions2 : void 0,
        enumerable: _extensions != null
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(_assertThisInitialized(_this), "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
      return _possibleConstructorReturn(_this);
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError2);
    } else {
      Object.defineProperty(_assertThisInitialized(_this), "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
    return _this;
  }
  _createClass$1(GraphQLError2, [{
    key: "toString",
    value: function toString() {
      return printError(this);
    }
  }, {
    key: SYMBOL_TO_STRING_TAG,
    get: function get() {
      return "Object";
    }
  }]);
  return GraphQLError2;
}(_wrapNativeSuper(Error));
function printError(error2) {
  var output = error2.message;
  if (error2.nodes) {
    for (var _i2 = 0, _error$nodes2 = error2.nodes; _i2 < _error$nodes2.length; _i2++) {
      var node = _error$nodes2[_i2];
      if (node.loc) {
        output += "\n\n" + printLocation(node.loc);
      }
    }
  } else if (error2.source && error2.locations) {
    for (var _i4 = 0, _error$locations2 = error2.locations; _i4 < _error$locations2.length; _i4++) {
      var location2 = _error$locations2[_i4];
      output += "\n\n" + printSourceLocation(error2.source, location2);
    }
  }
  return output;
}
function syntaxError(source, position2, description) {
  return new GraphQLError("Syntax Error: ".concat(description), void 0, source, [position2]);
}
var Kind = Object.freeze({
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType",
  SCHEMA_DEFINITION: "SchemaDefinition",
  OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
  SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
  OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
  FIELD_DEFINITION: "FieldDefinition",
  INPUT_VALUE_DEFINITION: "InputValueDefinition",
  INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
  UNION_TYPE_DEFINITION: "UnionTypeDefinition",
  ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
  ENUM_VALUE_DEFINITION: "EnumValueDefinition",
  INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
  DIRECTIVE_DEFINITION: "DirectiveDefinition",
  SCHEMA_EXTENSION: "SchemaExtension",
  SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
  OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
  INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
  UNION_TYPE_EXTENSION: "UnionTypeExtension",
  ENUM_TYPE_EXTENSION: "EnumTypeExtension",
  INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
});
function invariant2(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}
var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
function defineInspect(classObject) {
  var fn = classObject.prototype.toJSON;
  typeof fn === "function" || invariant2(0);
  classObject.prototype.inspect = fn;
  if (nodejsCustomInspectSymbol) {
    classObject.prototype[nodejsCustomInspectSymbol] = fn;
  }
}
var Location = function() {
  function Location2(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  var _proto = Location2.prototype;
  _proto.toJSON = function toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  };
  return Location2;
}();
defineInspect(Location);
var Token = function() {
  function Token2(kind, start, end, line, column, prev, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = prev;
    this.next = null;
  }
  var _proto2 = Token2.prototype;
  _proto2.toJSON = function toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  };
  return Token2;
}();
defineInspect(Token);
var TokenKind = Object.freeze({
  SOF: "<SOF>",
  EOF: "<EOF>",
  BANG: "!",
  DOLLAR: "$",
  AMP: "&",
  PAREN_L: "(",
  PAREN_R: ")",
  SPREAD: "...",
  COLON: ":",
  EQUALS: "=",
  AT: "@",
  BRACKET_L: "[",
  BRACKET_R: "]",
  BRACE_L: "{",
  PIPE: "|",
  BRACE_R: "}",
  NAME: "Name",
  INT: "Int",
  FLOAT: "Float",
  STRING: "String",
  BLOCK_STRING: "BlockString",
  COMMENT: "Comment"
});
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (_typeof$1(value)) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? "[function ".concat(value.name, "]") : "[function]";
    case "object":
      if (value === null) {
        return "null";
      }
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return "[Circular]";
  }
  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);
  if (customInspectFn !== void 0) {
    var customValue = customInspectFn.call(value);
    if (customValue !== value) {
      return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function formatObject(object, seenValues) {
  var keys = Object.keys(object);
  if (keys.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  var properties = keys.map(function(key) {
    var value = formatValue(object[key], seenValues);
    return key + ": " + value;
  });
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];
  for (var i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }
  return "[" + items.join(", ") + "]";
}
function getCustomFn(object) {
  var customInspectFn = object[String(nodejsCustomInspectSymbol)];
  if (typeof customInspectFn === "function") {
    return customInspectFn;
  }
  if (typeof object.inspect === "function") {
    return object.inspect;
  }
}
function getObjectTag(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    var name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
function devAssert(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var instanceOf = function instanceOf2(value, constructor) {
  if (value instanceof constructor) {
    return true;
  }
  if (_typeof(value) === "object" && value !== null) {
    var _value$constructor;
    var className = constructor.prototype[Symbol.toStringTag];
    var valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
    if (className === valueClassName) {
      var stringifiedValue = inspect(value);
      throw new Error("Cannot use ".concat(className, ' "').concat(stringifiedValue, '" from another module or realm.\n\nEnsure that there is only one instance of "graphql" in the node_modules\ndirectory. If different versions of "graphql" are the dependencies of other\nrelied on modules, use "resolutions" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate "graphql" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.'));
    }
  }
  return false;
};
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var Source = function() {
  function Source2(body2) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request";
    var locationOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      line: 1,
      column: 1
    };
    typeof body2 === "string" || devAssert(0, "Body must be a string. Received: ".concat(inspect(body2), "."));
    this.body = body2;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(0, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(0, "column in locationOffset is 1-indexed and must be positive.");
  }
  _createClass(Source2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get() {
      return "Source";
    }
  }]);
  return Source2;
}();
function isSource(source) {
  return instanceOf(source, Source);
}
var DirectiveLocation = Object.freeze({
  QUERY: "QUERY",
  MUTATION: "MUTATION",
  SUBSCRIPTION: "SUBSCRIPTION",
  FIELD: "FIELD",
  FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
  FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
  INLINE_FRAGMENT: "INLINE_FRAGMENT",
  VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
  SCHEMA: "SCHEMA",
  SCALAR: "SCALAR",
  OBJECT: "OBJECT",
  FIELD_DEFINITION: "FIELD_DEFINITION",
  ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
  INTERFACE: "INTERFACE",
  UNION: "UNION",
  ENUM: "ENUM",
  ENUM_VALUE: "ENUM_VALUE",
  INPUT_OBJECT: "INPUT_OBJECT",
  INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
});
function dedentBlockStringValue(rawString) {
  var lines = rawString.split(/\r\n|[\n\r]/g);
  var commonIndent = getBlockStringIndentation(rawString);
  if (commonIndent !== 0) {
    for (var i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  var startLine = 0;
  while (startLine < lines.length && isBlank(lines[startLine])) {
    ++startLine;
  }
  var endLine = lines.length;
  while (endLine > startLine && isBlank(lines[endLine - 1])) {
    --endLine;
  }
  return lines.slice(startLine, endLine).join("\n");
}
function isBlank(str) {
  for (var i = 0; i < str.length; ++i) {
    if (str[i] !== " " && str[i] !== "	") {
      return false;
    }
  }
  return true;
}
function getBlockStringIndentation(value) {
  var _commonIndent;
  var isFirstLine = true;
  var isEmptyLine = true;
  var indent = 0;
  var commonIndent = null;
  for (var i = 0; i < value.length; ++i) {
    switch (value.charCodeAt(i)) {
      case 13:
        if (value.charCodeAt(i + 1) === 10) {
          ++i;
        }
      case 10:
        isFirstLine = false;
        isEmptyLine = true;
        indent = 0;
        break;
      case 9:
      case 32:
        ++indent;
        break;
      default:
        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {
          commonIndent = indent;
        }
        isEmptyLine = false;
    }
  }
  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
}
var Lexer = function() {
  function Lexer2(source) {
    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  var _proto = Lexer2.prototype;
  _proto.advance = function advance() {
    this.lastToken = this.token;
    var token = this.token = this.lookahead();
    return token;
  };
  _proto.lookahead = function lookahead() {
    var token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        var _token$next;
        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  };
  return Lexer2;
}();
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function printCharCode(code) {
  return isNaN(code) ? TokenKind.EOF : code < 127 ? JSON.stringify(String.fromCharCode(code)) : '"\\u'.concat(("00" + code.toString(16).toUpperCase()).slice(-4), '"');
}
function readToken(lexer, prev) {
  var source = lexer.source;
  var body2 = source.body;
  var bodyLength = body2.length;
  var pos = prev.end;
  while (pos < bodyLength) {
    var code = body2.charCodeAt(pos);
    var _line = lexer.line;
    var _col = 1 + pos - lexer.lineStart;
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++pos;
        continue;
      case 10:
        ++pos;
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 13:
        if (body2.charCodeAt(pos + 1) === 10) {
          pos += 2;
        } else {
          ++pos;
        }
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 33:
        return new Token(TokenKind.BANG, pos, pos + 1, _line, _col, prev);
      case 35:
        return readComment(source, pos, _line, _col, prev);
      case 36:
        return new Token(TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);
      case 38:
        return new Token(TokenKind.AMP, pos, pos + 1, _line, _col, prev);
      case 40:
        return new Token(TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);
      case 41:
        return new Token(TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);
      case 46:
        if (body2.charCodeAt(pos + 1) === 46 && body2.charCodeAt(pos + 2) === 46) {
          return new Token(TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);
        }
        break;
      case 58:
        return new Token(TokenKind.COLON, pos, pos + 1, _line, _col, prev);
      case 61:
        return new Token(TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);
      case 64:
        return new Token(TokenKind.AT, pos, pos + 1, _line, _col, prev);
      case 91:
        return new Token(TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);
      case 93:
        return new Token(TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);
      case 123:
        return new Token(TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);
      case 124:
        return new Token(TokenKind.PIPE, pos, pos + 1, _line, _col, prev);
      case 125:
        return new Token(TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);
      case 34:
        if (body2.charCodeAt(pos + 1) === 34 && body2.charCodeAt(pos + 2) === 34) {
          return readBlockString(source, pos, _line, _col, prev, lexer);
        }
        return readString(source, pos, _line, _col, prev);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return readNumber(source, pos, code, _line, _col, prev);
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 95:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
        return readName(source, pos, _line, _col, prev);
    }
    throw syntaxError(source, pos, unexpectedCharacterMessage(code));
  }
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;
  return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
}
function unexpectedCharacterMessage(code) {
  if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
    return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
  }
  if (code === 39) {
    return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
  }
  return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
}
function readComment(source, start, line, col, prev) {
  var body2 = source.body;
  var code;
  var position2 = start;
  do {
    code = body2.charCodeAt(++position2);
  } while (!isNaN(code) && (code > 31 || code === 9));
  return new Token(TokenKind.COMMENT, start, position2, line, col, prev, body2.slice(start + 1, position2));
}
function readNumber(source, start, firstCode, line, col, prev) {
  var body2 = source.body;
  var code = firstCode;
  var position2 = start;
  var isFloat = false;
  if (code === 45) {
    code = body2.charCodeAt(++position2);
  }
  if (code === 48) {
    code = body2.charCodeAt(++position2);
    if (code >= 48 && code <= 57) {
      throw syntaxError(source, position2, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
    }
  } else {
    position2 = readDigits(source, position2, code);
    code = body2.charCodeAt(position2);
  }
  if (code === 46) {
    isFloat = true;
    code = body2.charCodeAt(++position2);
    position2 = readDigits(source, position2, code);
    code = body2.charCodeAt(position2);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body2.charCodeAt(++position2);
    if (code === 43 || code === 45) {
      code = body2.charCodeAt(++position2);
    }
    position2 = readDigits(source, position2, code);
    code = body2.charCodeAt(position2);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(source, position2, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
  }
  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position2, line, col, prev, body2.slice(start, position2));
}
function readDigits(source, start, firstCode) {
  var body2 = source.body;
  var position2 = start;
  var code = firstCode;
  if (code >= 48 && code <= 57) {
    do {
      code = body2.charCodeAt(++position2);
    } while (code >= 48 && code <= 57);
    return position2;
  }
  throw syntaxError(source, position2, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
}
function readString(source, start, line, col, prev) {
  var body2 = source.body;
  var position2 = start + 1;
  var chunkStart = position2;
  var code = 0;
  var value = "";
  while (position2 < body2.length && !isNaN(code = body2.charCodeAt(position2)) && code !== 10 && code !== 13) {
    if (code === 34) {
      value += body2.slice(chunkStart, position2);
      return new Token(TokenKind.STRING, start, position2 + 1, line, col, prev, value);
    }
    if (code < 32 && code !== 9) {
      throw syntaxError(source, position2, "Invalid character within String: ".concat(printCharCode(code), "."));
    }
    ++position2;
    if (code === 92) {
      value += body2.slice(chunkStart, position2 - 1);
      code = body2.charCodeAt(position2);
      switch (code) {
        case 34:
          value += '"';
          break;
        case 47:
          value += "/";
          break;
        case 92:
          value += "\\";
          break;
        case 98:
          value += "\b";
          break;
        case 102:
          value += "\f";
          break;
        case 110:
          value += "\n";
          break;
        case 114:
          value += "\r";
          break;
        case 116:
          value += "	";
          break;
        case 117: {
          var charCode = uniCharCode(body2.charCodeAt(position2 + 1), body2.charCodeAt(position2 + 2), body2.charCodeAt(position2 + 3), body2.charCodeAt(position2 + 4));
          if (charCode < 0) {
            var invalidSequence = body2.slice(position2 + 1, position2 + 5);
            throw syntaxError(source, position2, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
          }
          value += String.fromCharCode(charCode);
          position2 += 4;
          break;
        }
        default:
          throw syntaxError(source, position2, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
      }
      ++position2;
      chunkStart = position2;
    }
  }
  throw syntaxError(source, position2, "Unterminated string.");
}
function readBlockString(source, start, line, col, prev, lexer) {
  var body2 = source.body;
  var position2 = start + 3;
  var chunkStart = position2;
  var code = 0;
  var rawValue = "";
  while (position2 < body2.length && !isNaN(code = body2.charCodeAt(position2))) {
    if (code === 34 && body2.charCodeAt(position2 + 1) === 34 && body2.charCodeAt(position2 + 2) === 34) {
      rawValue += body2.slice(chunkStart, position2);
      return new Token(TokenKind.BLOCK_STRING, start, position2 + 3, line, col, prev, dedentBlockStringValue(rawValue));
    }
    if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
      throw syntaxError(source, position2, "Invalid character within String: ".concat(printCharCode(code), "."));
    }
    if (code === 10) {
      ++position2;
      ++lexer.line;
      lexer.lineStart = position2;
    } else if (code === 13) {
      if (body2.charCodeAt(position2 + 1) === 10) {
        position2 += 2;
      } else {
        ++position2;
      }
      ++lexer.line;
      lexer.lineStart = position2;
    } else if (code === 92 && body2.charCodeAt(position2 + 1) === 34 && body2.charCodeAt(position2 + 2) === 34 && body2.charCodeAt(position2 + 3) === 34) {
      rawValue += body2.slice(chunkStart, position2) + '"""';
      position2 += 4;
      chunkStart = position2;
    } else {
      ++position2;
    }
  }
  throw syntaxError(source, position2, "Unterminated string.");
}
function uniCharCode(a, b, c, d) {
  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
}
function char2hex(a) {
  return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;
}
function readName(source, start, line, col, prev) {
  var body2 = source.body;
  var bodyLength = body2.length;
  var position2 = start + 1;
  var code = 0;
  while (position2 !== bodyLength && !isNaN(code = body2.charCodeAt(position2)) && (code === 95 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {
    ++position2;
  }
  return new Token(TokenKind.NAME, start, position2, line, col, prev, body2.slice(start, position2));
}
function isNameStart(code) {
  return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
}
function parse2(source, options) {
  var parser = new Parser(source, options);
  return parser.parseDocument();
}
var Parser = function() {
  function Parser2(source, options) {
    var sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
  }
  var _proto = Parser2.prototype;
  _proto.parseName = function parseName() {
    var token = this.expectToken(TokenKind.NAME);
    return {
      kind: Kind.NAME,
      value: token.value,
      loc: this.loc(token)
    };
  };
  _proto.parseDocument = function parseDocument() {
    var start = this._lexer.token;
    return {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),
      loc: this.loc(start)
    };
  };
  _proto.parseDefinition = function parseDefinition() {
    if (this.peek(TokenKind.NAME)) {
      switch (this._lexer.token.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "schema":
        case "scalar":
        case "type":
        case "interface":
        case "union":
        case "enum":
        case "input":
        case "directive":
          return this.parseTypeSystemDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    } else if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    } else if (this.peekDescription()) {
      return this.parseTypeSystemDefinition();
    }
    throw this.unexpected();
  };
  _proto.parseOperationDefinition = function parseOperationDefinition() {
    var start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return {
        kind: Kind.OPERATION_DEFINITION,
        operation: "query",
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }
    var operation = this.parseOperationType();
    var name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseOperationType = function parseOperationType() {
    var operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return "query";
      case "mutation":
        return "mutation";
      case "subscription":
        return "subscription";
    }
    throw this.unexpected(operationToken);
  };
  _proto.parseVariableDefinitions = function parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  };
  _proto.parseVariableDefinition = function parseVariableDefinition() {
    var start = this._lexer.token;
    return {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0,
      directives: this.parseDirectives(true),
      loc: this.loc(start)
    };
  };
  _proto.parseVariable = function parseVariable() {
    var start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return {
      kind: Kind.VARIABLE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  };
  _proto.parseSelectionSet = function parseSelectionSet() {
    var start = this._lexer.token;
    return {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  };
  _proto.parseSelection = function parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  };
  _proto.parseField = function parseField() {
    var start = this._lexer.token;
    var nameOrAlias = this.parseName();
    var alias;
    var name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
      loc: this.loc(start)
    };
  };
  _proto.parseArguments = function parseArguments(isConst) {
    var item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  };
  _proto.parseArgument = function parseArgument() {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(false),
      loc: this.loc(start)
    };
  };
  _proto.parseConstArgument = function parseConstArgument() {
    var start = this._lexer.token;
    return {
      kind: Kind.ARGUMENT,
      name: this.parseName(),
      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),
      loc: this.loc(start)
    };
  };
  _proto.parseFragment = function parseFragment() {
    var start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    var hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false),
        loc: this.loc(start)
      };
    }
    return {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseFragmentDefinition = function parseFragmentDefinition() {
    var _this$_options;
    var start = this._lexer.token;
    this.expectKeyword("fragment");
    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
      return {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }
    return {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseFragmentName = function parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  };
  _proto.parseValueLiteral = function parseValueLiteral(isConst) {
    var token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this._lexer.advance();
        return {
          kind: Kind.INT,
          value: token.value,
          loc: this.loc(token)
        };
      case TokenKind.FLOAT:
        this._lexer.advance();
        return {
          kind: Kind.FLOAT,
          value: token.value,
          loc: this.loc(token)
        };
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this._lexer.advance();
        switch (token.value) {
          case "true":
            return {
              kind: Kind.BOOLEAN,
              value: true,
              loc: this.loc(token)
            };
          case "false":
            return {
              kind: Kind.BOOLEAN,
              value: false,
              loc: this.loc(token)
            };
          case "null":
            return {
              kind: Kind.NULL,
              loc: this.loc(token)
            };
          default:
            return {
              kind: Kind.ENUM,
              value: token.value,
              loc: this.loc(token)
            };
        }
      case TokenKind.DOLLAR:
        if (!isConst) {
          return this.parseVariable();
        }
        break;
    }
    throw this.unexpected();
  };
  _proto.parseStringLiteral = function parseStringLiteral() {
    var token = this._lexer.token;
    this._lexer.advance();
    return {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING,
      loc: this.loc(token)
    };
  };
  _proto.parseList = function parseList(isConst) {
    var _this = this;
    var start = this._lexer.token;
    var item = function item2() {
      return _this.parseValueLiteral(isConst);
    };
    return {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
      loc: this.loc(start)
    };
  };
  _proto.parseObject = function parseObject(isConst) {
    var _this2 = this;
    var start = this._lexer.token;
    var item = function item2() {
      return _this2.parseObjectField(isConst);
    };
    return {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  };
  _proto.parseObjectField = function parseObjectField(isConst) {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst),
      loc: this.loc(start)
    };
  };
  _proto.parseDirectives = function parseDirectives(isConst) {
    var directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  };
  _proto.parseDirective = function parseDirective(isConst) {
    var start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst),
      loc: this.loc(start)
    };
  };
  _proto.parseTypeReference = function parseTypeReference() {
    var start = this._lexer.token;
    var type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      type = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = {
        kind: Kind.LIST_TYPE,
        type,
        loc: this.loc(start)
      };
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return {
        kind: Kind.NON_NULL_TYPE,
        type,
        loc: this.loc(start)
      };
    }
    return type;
  };
  _proto.parseNamedType = function parseNamedType() {
    var start = this._lexer.token;
    return {
      kind: Kind.NAMED_TYPE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  };
  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.peekDescription = function peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  };
  _proto.parseDescription = function parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  };
  _proto.parseSchemaDefinition = function parseSchemaDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("schema");
    var directives = this.parseDirectives(true);
    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes,
      loc: this.loc(start)
    };
  };
  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
    var start = this._lexer.token;
    var operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    var type = this.parseNamedType();
    return {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type,
      loc: this.loc(start)
    };
  };
  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("scalar");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("type");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
    var _this$_options2;
    if (!this.expectOptionalKeyword("implements")) {
      return [];
    }
    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
      var types = [];
      this.expectOptionalToken(TokenKind.AMP);
      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));
      return types;
    }
    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);
  };
  _proto.parseFieldsDefinition = function parseFieldsDefinition() {
    var _this$_options3;
    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {
      this._lexer.advance();
      this._lexer.advance();
      return [];
    }
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  };
  _proto.parseFieldDefinition = function parseFieldDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    var type = this.parseTypeReference();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseArgumentDefs = function parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  };
  _proto.parseInputValueDef = function parseInputValueDef() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    var type = this.parseTypeReference();
    var defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseValueLiteral(true);
    }
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("interface");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("union");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    return {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  };
  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("enum");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    return {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values,
      loc: this.loc(start)
    };
  };
  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  };
  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("input");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    return {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  };
  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
    var keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.parseSchemaExtension = function parseSchemaExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    var directives = this.parseDirectives(true);
    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes,
      loc: this.loc(start)
    };
  };
  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types,
      loc: this.loc(start)
    };
  };
  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values,
      loc: this.loc(start)
    };
  };
  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    var repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    var locations = this.parseDirectiveLocations();
    return {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations,
      loc: this.loc(start)
    };
  };
  _proto.parseDirectiveLocations = function parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  };
  _proto.parseDirectiveLocation = function parseDirectiveLocation() {
    var start = this._lexer.token;
    var name = this.parseName();
    if (DirectiveLocation[name.value] !== void 0) {
      return name;
    }
    throw this.unexpected(start);
  };
  _proto.loc = function loc(startToken) {
    var _this$_options4;
    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
      return new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
  };
  _proto.peek = function peek(kind) {
    return this._lexer.token.kind === kind;
  };
  _proto.expectToken = function expectToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
  };
  _proto.expectOptionalToken = function expectOptionalToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    return void 0;
  };
  _proto.expectKeyword = function expectKeyword(value) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
    } else {
      throw syntaxError(this._lexer.source, token.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token), "."));
    }
  };
  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
      return true;
    }
    return false;
  };
  _proto.unexpected = function unexpected(atToken) {
    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
  };
  _proto.any = function any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  };
  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      var nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  };
  _proto.many = function many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  };
  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  };
  return Parser2;
}();
function getTokenDesc(token) {
  var value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ' "'.concat(value, '"') : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? '"'.concat(kind, '"') : kind;
}
function parseDocumentNode(node) {
  var _a;
  const operationDef = node.definitions.find((def) => {
    return def.kind === "OperationDefinition";
  });
  return {
    operationType: operationDef === null || operationDef === void 0 ? void 0 : operationDef.operation,
    operationName: (_a = operationDef === null || operationDef === void 0 ? void 0 : operationDef.name) === null || _a === void 0 ? void 0 : _a.value
  };
}
function parseQuery(query) {
  try {
    const ast = parse2(query);
    return parseDocumentNode(ast);
  } catch (error2) {
    return error2;
  }
}
function extractMultipartVariables(variables, map, files) {
  const operations = { variables };
  for (const [key, pathArray] of Object.entries(map)) {
    if (!(key in files)) {
      throw new Error(`Given files do not have a key '${key}' .`);
    }
    for (const dotPath of pathArray) {
      const [lastPath, ...reversedPaths] = dotPath.split(".").reverse();
      const paths = reversedPaths.reverse();
      let target = operations;
      for (const path of paths) {
        if (!(path in target)) {
          throw new Error(`Property '${paths}' is not in operations.`);
        }
        target = target[path];
      }
      target[lastPath] = files[key];
    }
  }
  return operations.variables;
}
function getGraphQLInput(request) {
  var _a, _b;
  switch (request.method) {
    case "GET": {
      const query = request.url.searchParams.get("query");
      const variables = request.url.searchParams.get("variables") || "";
      return {
        query,
        variables: jsonParse(variables)
      };
    }
    case "POST": {
      if ((_a = request.body) === null || _a === void 0 ? void 0 : _a.query) {
        const { query, variables } = request.body;
        return {
          query,
          variables
        };
      }
      if ((_b = request.body) === null || _b === void 0 ? void 0 : _b.operations) {
        const _c = request.body, { operations, map } = _c, files = __rest(_c, ["operations", "map"]);
        const parsedOperations = jsonParse(operations) || {};
        if (!parsedOperations.query) {
          return null;
        }
        const parsedMap = jsonParse(map || "") || {};
        const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};
        return {
          query: parsedOperations.query,
          variables
        };
      }
    }
    default:
      return null;
  }
}
function parseGraphQLRequest(request) {
  const input = getGraphQLInput(request);
  if (!input || !input.query) {
    return void 0;
  }
  const { query, variables } = input;
  const parsedResult = parseQuery(query);
  if (parsedResult instanceof Error) {
    const requestPublicUrl = getPublicUrlFromRequest(request);
    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to "%s %s": cannot parse query. See the error message from the parser below.\n\n%s', request.method, requestPublicUrl, parsedResult.message));
  }
  return {
    operationType: parsedResult.operationType,
    operationName: parsedResult.operationName,
    variables
  };
}
function tryCatch(fn, onException) {
  try {
    const result = fn();
    return result;
  } catch (error2) {
    onException === null || onException === void 0 ? void 0 : onException(error2);
  }
}
var graphqlContext = {
  set,
  status,
  delay,
  fetch: fetch2,
  data,
  errors,
  cookie
};
function isDocumentNode(value) {
  if (value == null) {
    return false;
  }
  return typeof value === "object" && "kind" in value && "definitions" in value;
}
var GraphQLHandler = class extends RequestHandler {
  constructor(operationType, operationName, endpoint, resolver) {
    let resolvedOperationName = operationName;
    if (isDocumentNode(operationName)) {
      const parsedNode = parseDocumentNode(operationName);
      if (parsedNode.operationType !== operationType) {
        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected "${operationType}", but got "${parsedNode.operationType}").`);
      }
      if (!parsedNode.operationName) {
        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`);
      }
      resolvedOperationName = parsedNode.operationName;
    }
    const header = operationType === "all" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;
    super({
      info: {
        header,
        operationType,
        operationName: resolvedOperationName
      },
      ctx: graphqlContext,
      resolver
    });
    this.endpoint = endpoint;
  }
  parse(request) {
    return tryCatch(() => parseGraphQLRequest(request), (error2) => console.error(error2.message));
  }
  getPublicRequest(request, parsedResult) {
    return Object.assign(Object.assign({}, request), { variables: (parsedResult === null || parsedResult === void 0 ? void 0 : parsedResult.variables) || {} });
  }
  predicate(request, parsedResult) {
    if (!parsedResult) {
      return false;
    }
    if (!parsedResult.operationName) {
      const publicUrl = getPublicUrlFromRequest(request);
      devUtils.warn(`Failed to intercept a GraphQL request at "${request.method} ${publicUrl}": unnamed GraphQL operations are not supported.

Consider naming this operation or using "graphql.operation" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);
      return false;
    }
    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);
    const hasMatchingOperationType = this.info.operationType === "all" || parsedResult.operationType === this.info.operationType;
    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName) : parsedResult.operationName === this.info.operationName;
    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;
  }
  log(request, response2, handler, parsedRequest) {
    const loggedRequest = prepareRequest(request);
    const loggedResponse = prepareResponse(response2);
    const statusColor = getStatusCodeColor(response2.status);
    console.groupCollapsed(devUtils.formatMessage("%s %s (%c%s%c)"), getTimestamp(), `${parsedRequest === null || parsedRequest === void 0 ? void 0 : parsedRequest.operationType} ${parsedRequest === null || parsedRequest === void 0 ? void 0 : parsedRequest.operationName}`, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, "color:inherit");
    console.log("Request:", loggedRequest);
    console.log("Handler:", this);
    console.log("Response:", loggedResponse);
    console.groupEnd();
  }
};
function createScopedGraphQLHandler(operationType, url) {
  return (operationName, resolver) => {
    return new GraphQLHandler(operationType, operationName, url, resolver);
  };
}
function createGraphQLOperationHandler(url) {
  return (resolver) => {
    return new GraphQLHandler("all", new RegExp(".*"), url, resolver);
  };
}
var standardGraphQLHandlers = {
  operation: createGraphQLOperationHandler("*"),
  query: createScopedGraphQLHandler("query", "*"),
  mutation: createScopedGraphQLHandler("mutation", "*")
};
function createGraphQLLink(url) {
  return {
    operation: createGraphQLOperationHandler(url),
    query: createScopedGraphQLHandler("query", url),
    mutation: createScopedGraphQLHandler("mutation", url)
  };
}
var graphql = Object.assign(Object.assign({}, standardGraphQLHandlers), { link: createGraphQLLink });

// node_modules/msw/lib/esm/index.js
var import_debug = __toESM(require_browser2());
var lib$3 = {};
var StrictEventEmitter$1 = {};
var events = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++)
    args.push(arguments[i]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners3[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position2, i, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position2 = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position2 = i;
        break;
      }
    }
    if (position2 < 0)
      return this;
    if (position2 === 0)
      list.shift();
    else {
      spliceOne(list, position2);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners3, events2, i;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events2[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3 !== void 0) {
    for (i = listeners3.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners3[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy2 = new Array(n);
  for (var i = 0; i < n; ++i)
    copy2[i] = arr[i];
  return copy2;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once2(emitter, name) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
StrictEventEmitter$1.__esModule = true;
StrictEventEmitter$1.StrictEventEmitter = void 0;
var events_1 = events.exports;
var StrictEventEmitter = function(_super) {
  __extends$1(StrictEventEmitter2, _super);
  function StrictEventEmitter2() {
    return _super.call(this) || this;
  }
  StrictEventEmitter2.prototype.on = function(event, listener) {
    return _super.prototype.on.call(this, event.toString(), listener);
  };
  StrictEventEmitter2.prototype.once = function(event, listener) {
    return _super.prototype.on.call(this, event.toString(), listener);
  };
  StrictEventEmitter2.prototype.off = function(event, listener) {
    return _super.prototype.off.call(this, event.toString(), listener);
  };
  StrictEventEmitter2.prototype.emit = function(event) {
    var data2 = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      data2[_i - 1] = arguments[_i];
    }
    return _super.prototype.emit.apply(this, __spreadArrays([event.toString()], data2));
  };
  StrictEventEmitter2.prototype.addListener = function(event, listener) {
    return _super.prototype.addListener.call(this, event.toString(), listener);
  };
  StrictEventEmitter2.prototype.removeListener = function(event, listener) {
    return _super.prototype.removeListener.call(this, event.toString(), listener);
  };
  return StrictEventEmitter2;
}(events_1.EventEmitter);
StrictEventEmitter$1.StrictEventEmitter = StrictEventEmitter;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  exports.__esModule = true;
  exports.StrictEventEmitter = void 0;
  var StrictEventEmitter_1 = StrictEventEmitter$1;
  __createBinding(exports, StrictEventEmitter_1, "StrictEventEmitter");
})(lib$3);
var lib$2 = {};
var until$1 = {};
Object.defineProperty(until$1, "__esModule", { value: true });
until$1.until = async (promise) => {
  try {
    const data2 = await promise().catch((error2) => {
      throw error2;
    });
    return [null, data2];
  } catch (error2) {
    return [error2, null];
  }
};
Object.defineProperty(lib$2, "__esModule", { value: true });
var until_1$1 = until$1;
var until = lib$2.until = until_1$1.until;
var getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {
  const allStates = [
    registration.active,
    registration.installing,
    registration.waiting
  ];
  const existingStates = allStates.filter(Boolean);
  const mockWorker = existingStates.find((worker2) => {
    return findWorker(worker2.scriptURL, absoluteWorkerUrl);
  });
  return mockWorker || null;
};
function getAbsoluteWorkerUrl(relativeUrl) {
  return new URL(relativeUrl, location.origin).href;
}
var getWorkerInstance = (url, options = {}, findWorker) => __awaiter(void 0, void 0, void 0, function* () {
  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);
  const mockRegistrations = yield navigator.serviceWorker.getRegistrations().then((registrations) => registrations.filter((registration) => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));
  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {
    location.reload();
  }
  const [existingRegistration] = mockRegistrations;
  if (existingRegistration) {
    return existingRegistration.update().then(() => {
      return [
        getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker),
        existingRegistration
      ];
    });
  }
  const [error2, instance] = yield until(() => __awaiter(void 0, void 0, void 0, function* () {
    const registration = yield navigator.serviceWorker.register(url, options);
    return [
      getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),
      registration
    ];
  }));
  if (error2) {
    const isWorkerMissing = error2.message.includes("(404)");
    if (isWorkerMissing) {
      const scopeUrl = new URL((options === null || options === void 0 ? void 0 : options.scope) || "/", location.href);
      throw new Error(devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.

Did you forget to run "npx msw init <PUBLIC_DIR>"?

Learn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));
    }
    throw new Error(devUtils.formatMessage("Failed to register the Service Worker:\n\n%s", error2.message));
  }
  return instance;
});
function printStartMessage(args = {}) {
  if (args.quiet) {
    return;
  }
  const message = args.message || "Mocking enabled.";
  console.groupCollapsed(`%c${devUtils.formatMessage(message)}`, "color:orangered;font-weight:bold;");
  console.log("%cDocumentation: %chttps://mswjs.io/docs", "font-weight:bold", "font-weight:normal");
  console.log("Found an issue? https://github.com/mswjs/msw/issues");
  console.groupEnd();
}
function enableMocking(context, options) {
  return __awaiter(this, void 0, void 0, function* () {
    context.workerChannel.send("MOCK_ACTIVATE");
    return context.events.once("MOCKING_ENABLED").then(() => {
      printStartMessage({ quiet: options.quiet });
    });
  });
}
var createBroadcastChannel = (event) => {
  const port = event.ports[0];
  return {
    send(message) {
      if (port) {
        port.postMessage(message);
      }
    }
  };
};
var lib$12 = {};
var CookieStore = {};
var setCookie = { exports: {} };
var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false
};
function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}
function parseString(setCookieValue, options) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);
  var nameValue = parts.shift().split("=");
  var name = nameValue.shift();
  var value = nameValue.join("=");
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  try {
    value = options.decodeValues ? decodeURIComponent(value) : value;
  } catch (e) {
    console.error(
      "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
      e
    );
  }
  var cookie2 = {
    name,
    value
  };
  parts.forEach(function(part) {
    var sides = part.split("=");
    var key = sides.shift().trimLeft().toLowerCase();
    var value2 = sides.join("=");
    if (key === "expires") {
      cookie2.expires = new Date(value2);
    } else if (key === "max-age") {
      cookie2.maxAge = parseInt(value2, 10);
    } else if (key === "secure") {
      cookie2.secure = true;
    } else if (key === "httponly") {
      cookie2.httpOnly = true;
    } else if (key === "samesite") {
      cookie2.sameSite = value2;
    } else {
      cookie2[key] = value2;
    }
  });
  return cookie2;
}
function parse$1(input, options) {
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  if (!input) {
    if (!options.map) {
      return [];
    } else {
      return {};
    }
  }
  if (input.headers && input.headers["set-cookie"]) {
    input = input.headers["set-cookie"];
  } else if (input.headers) {
    var sch = input.headers[Object.keys(input.headers).find(function(key) {
      return key.toLowerCase() === "set-cookie";
    })];
    if (!sch && input.headers.cookie && !options.silent) {
      console.warn(
        "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
      );
    }
    input = sch;
  }
  if (!Array.isArray(input)) {
    input = [input];
  }
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  if (!options.map) {
    return input.filter(isNonEmptyString).map(function(str) {
      return parseString(str, options);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
      var cookie2 = parseString(str, options);
      cookies2[cookie2.name] = cookie2;
      return cookies2;
    }, cookies);
  }
}
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;
  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }
  function notSpecialChar() {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  }
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }
  return cookiesStrings;
}
setCookie.exports = parse$1;
setCookie.exports.parse = parse$1;
setCookie.exports.parseString = parseString;
setCookie.exports.splitCookiesString = splitCookiesString;
(function(exports) {
  var __rest2 = commonjsGlobal && commonjsGlobal.__rest || function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PERSISTENCY_KEY = void 0;
  const set_cookie_parser_1 = setCookie.exports;
  exports.PERSISTENCY_KEY = "MSW_COOKIE_STORE";
  const SUPPORTS_LOCAL_STORAGE = typeof localStorage !== "undefined";
  class CookieStore2 {
    constructor() {
      this.store = /* @__PURE__ */ new Map();
    }
    add(request, response2) {
      if (request.credentials === "omit") {
        return;
      }
      const requestUrl = new URL(request.url);
      const responseCookies = response2.headers.get("set-cookie");
      if (!responseCookies) {
        return;
      }
      const now = Date.now();
      const parsedResponseCookies = set_cookie_parser_1.parse(responseCookies).map((_a) => {
        var { maxAge } = _a, cookie2 = __rest2(_a, ["maxAge"]);
        return Object.assign(Object.assign({}, cookie2), { expires: maxAge === void 0 ? cookie2.expires : new Date(now + maxAge * 1e3), maxAge });
      });
      const prevCookies = this.store.get(requestUrl.origin) || /* @__PURE__ */ new Map();
      parsedResponseCookies.forEach((cookie2) => {
        this.store.set(requestUrl.origin, prevCookies.set(cookie2.name, cookie2));
      });
    }
    get(request) {
      this.deleteExpiredCookies();
      const requestUrl = new URL(request.url);
      const originCookies = this.store.get(requestUrl.origin) || /* @__PURE__ */ new Map();
      switch (request.credentials) {
        case "include": {
          const documentCookies = set_cookie_parser_1.parse(document.cookie);
          documentCookies.forEach((cookie2) => {
            originCookies.set(cookie2.name, cookie2);
          });
          return originCookies;
        }
        case "same-origin": {
          return originCookies;
        }
        default:
          return /* @__PURE__ */ new Map();
      }
    }
    getAll() {
      this.deleteExpiredCookies();
      return this.store;
    }
    deleteAll(request) {
      const requestUrl = new URL(request.url);
      this.store.delete(requestUrl.origin);
    }
    clear() {
      this.store.clear();
    }
    hydrate() {
      if (!SUPPORTS_LOCAL_STORAGE) {
        return;
      }
      const persistedCookies = localStorage.getItem(exports.PERSISTENCY_KEY);
      if (persistedCookies) {
        try {
          const parsedCookies = JSON.parse(persistedCookies);
          parsedCookies.forEach(([origin, cookies]) => {
            this.store.set(origin, new Map(cookies.map((_a) => {
              var [token, _b] = _a, { expires } = _b, cookie2 = __rest2(_b, ["expires"]);
              return [
                token,
                expires === void 0 ? cookie2 : Object.assign(Object.assign({}, cookie2), { expires: new Date(expires) })
              ];
            })));
          });
        } catch (error2) {
          console.warn(`
[virtual-cookie] Failed to parse a stored cookie from the localStorage (key "${exports.PERSISTENCY_KEY}").

Stored value:
${localStorage.getItem(exports.PERSISTENCY_KEY)}

Thrown exception:
${error2}

Invalid value has been removed from localStorage to prevent subsequent failed parsing attempts.`);
          localStorage.removeItem(exports.PERSISTENCY_KEY);
        }
      }
    }
    persist() {
      if (!SUPPORTS_LOCAL_STORAGE) {
        return;
      }
      const serializedCookies = Array.from(this.store.entries()).map(([origin, cookies]) => {
        return [origin, Array.from(cookies.entries())];
      });
      localStorage.setItem(exports.PERSISTENCY_KEY, JSON.stringify(serializedCookies));
    }
    deleteExpiredCookies() {
      const now = Date.now();
      this.store.forEach((originCookies, origin) => {
        originCookies.forEach(({ expires, name }) => {
          if (expires !== void 0 && expires.getTime() <= now) {
            originCookies.delete(name);
          }
        });
        if (originCookies.size === 0) {
          this.store.delete(origin);
        }
      });
    }
  }
  exports.default = new CookieStore2();
})(CookieStore);
(function(exports) {
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PERSISTENCY_KEY = exports.store = void 0;
  var CookieStore_1 = CookieStore;
  Object.defineProperty(exports, "store", { enumerable: true, get: function() {
    return __importDefault(CookieStore_1).default;
  } });
  Object.defineProperty(exports, "PERSISTENCY_KEY", { enumerable: true, get: function() {
    return CookieStore_1.PERSISTENCY_KEY;
  } });
})(lib$12);
function getAllCookies() {
  return parse_1(document.cookie);
}
function getRequestCookies(request) {
  if (typeof location === "undefined") {
    return {};
  }
  switch (request.credentials) {
    case "same-origin": {
      return location.origin === request.url.origin ? getAllCookies() : {};
    }
    case "include": {
      return getAllCookies();
    }
    default: {
      return {};
    }
  }
}
function setRequestCookies(request) {
  var _a;
  lib$12.store.hydrate();
  request.cookies = Object.assign(Object.assign({}, getRequestCookies(request)), Array.from((_a = lib$12.store.get(Object.assign(Object.assign({}, request), { url: request.url.toString() }))) === null || _a === void 0 ? void 0 : _a.entries()).reduce((cookies, [name, { value }]) => Object.assign(cookies, { [name]: value }), {}));
  request.headers.set("cookie", Object.entries(request.cookies).map(([name, value]) => `${name}=${value}`).join("; "));
}
function pruneGetRequestBody(request) {
  if (request.method && isStringEqual(request.method, "GET") && request.body === "") {
    return void 0;
  }
  return request.body;
}
function parseWorkerRequest(rawRequest) {
  const request = {
    id: rawRequest.id,
    cache: rawRequest.cache,
    credentials: rawRequest.credentials,
    method: rawRequest.method,
    url: new URL(rawRequest.url),
    referrer: rawRequest.referrer,
    referrerPolicy: rawRequest.referrerPolicy,
    redirect: rawRequest.redirect,
    mode: rawRequest.mode,
    params: {},
    cookies: {},
    integrity: rawRequest.integrity,
    keepalive: rawRequest.keepalive,
    destination: rawRequest.destination,
    body: pruneGetRequestBody(rawRequest),
    bodyUsed: rawRequest.bodyUsed,
    headers: new lib$1.Headers(rawRequest.headers)
  };
  setRequestCookies(request);
  request.body = parseBody(request.body, request.headers);
  return request;
}
var getResponse = (request, handlers2, resolutionContext) => __awaiter(void 0, void 0, void 0, function* () {
  const relevantHandlers = handlers2.filter((handler) => {
    return handler.test(request, resolutionContext);
  });
  if (relevantHandlers.length === 0) {
    return {
      handler: void 0,
      response: void 0
    };
  }
  const result = yield relevantHandlers.reduce((executionResult, handler) => __awaiter(void 0, void 0, void 0, function* () {
    const previousResults = yield executionResult;
    if (!!(previousResults === null || previousResults === void 0 ? void 0 : previousResults.response)) {
      return executionResult;
    }
    const result2 = yield handler.run(request, resolutionContext);
    if (result2 === null || result2.handler.shouldSkip) {
      return null;
    }
    if (!result2.response) {
      return {
        request: result2.request,
        handler: result2.handler,
        response: void 0,
        parsedResult: result2.parsedResult
      };
    }
    if (result2.response.once) {
      handler.markAsSkipped(true);
    }
    return result2;
  }), Promise.resolve(null));
  if (!result) {
    return {
      handler: void 0,
      response: void 0
    };
  }
  return {
    handler: result.handler,
    publicRequest: result.request,
    parsedRequest: result.parsedResult,
    response: result.response
  };
});
var jsLevenshtein = function() {
  function _min(d0, d1, d2, bx, ay) {
    return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;
  }
  return function(a, b) {
    if (a === b) {
      return 0;
    }
    if (a.length > b.length) {
      var tmp = a;
      a = b;
      b = tmp;
    }
    var la = a.length;
    var lb = b.length;
    while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
      la--;
      lb--;
    }
    var offset = 0;
    while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {
      offset++;
    }
    la -= offset;
    lb -= offset;
    if (la === 0 || lb < 3) {
      return lb;
    }
    var x = 0;
    var y;
    var d0;
    var d1;
    var d2;
    var d3;
    var dd;
    var dy;
    var ay;
    var bx0;
    var bx1;
    var bx2;
    var bx3;
    var vector = [];
    for (y = 0; y < la; y++) {
      vector.push(y + 1);
      vector.push(a.charCodeAt(offset + y));
    }
    var len = vector.length - 1;
    for (; x < lb - 3; ) {
      bx0 = b.charCodeAt(offset + (d0 = x));
      bx1 = b.charCodeAt(offset + (d1 = x + 1));
      bx2 = b.charCodeAt(offset + (d2 = x + 2));
      bx3 = b.charCodeAt(offset + (d3 = x + 3));
      dd = x += 4;
      for (y = 0; y < len; y += 2) {
        dy = vector[y];
        ay = vector[y + 1];
        d0 = _min(dy, d0, d1, bx0, ay);
        d1 = _min(d0, d1, d2, bx1, ay);
        d2 = _min(d1, d2, d3, bx2, ay);
        dd = _min(d2, d3, dd, bx3, ay);
        vector[y] = dd;
        d3 = d2;
        d2 = d1;
        d1 = d0;
        d0 = dy;
      }
    }
    for (; x < lb; ) {
      bx0 = b.charCodeAt(offset + (d0 = x));
      dd = ++x;
      for (y = 0; y < len; y += 2) {
        dy = vector[y];
        vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);
        d0 = dy;
      }
    }
    return dd;
  };
}();
var MAX_MATCH_SCORE = 3;
var MAX_SUGGESTION_COUNT = 4;
var TYPE_MATCH_DELTA = 0.5;
function groupHandlersByType(handlers2) {
  return handlers2.reduce((groups, handler) => {
    if (handler instanceof RestHandler) {
      groups.rest.push(handler);
    }
    if (handler instanceof GraphQLHandler) {
      groups.graphql.push(handler);
    }
    return groups;
  }, {
    rest: [],
    graphql: []
  });
}
function getScoreForRestHandler() {
  return (request, handler) => {
    const { path, method } = handler.info;
    if (path instanceof RegExp) {
      return Infinity;
    }
    const hasSameMethod = isStringEqual(request.method, method);
    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;
    const requestPublicUrl = getPublicUrlFromRequest(request);
    const score = jsLevenshtein(requestPublicUrl, path);
    return score - methodScoreDelta;
  };
}
function getScoreForGraphQLHandler(parsedQuery) {
  return (_, handler) => {
    if (typeof parsedQuery.operationName === "undefined") {
      return Infinity;
    }
    const { operationType, operationName } = handler.info;
    const hasSameOperationType = parsedQuery.operationType === operationType;
    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;
    const score = jsLevenshtein(parsedQuery.operationName, operationName);
    return score - operationTypeScoreDelta;
  };
}
function getSuggestedHandler(request, handlers2, getScore) {
  const suggestedHandlers = handlers2.reduce((acc, handler) => {
    const score = getScore(request, handler);
    return acc.concat([[score, handler]]);
  }, []).sort(([leftScore], [rightScore]) => {
    return leftScore - rightScore;
  }).filter(([score]) => {
    return score <= MAX_MATCH_SCORE;
  }).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);
  return suggestedHandlers;
}
function getSuggestedHandlersMessage(handlers2) {
  if (handlers2.length > 1) {
    return `Did you mean to request one of the following resources instead?

${handlers2.map((handler) => `  \u2022 ${handler.info.header}`).join("\n")}`;
  }
  return `Did you mean to request "${handlers2[0].info.header}" instead?`;
}
function onUnhandledRequest(request, handlers2, strategy = "warn") {
  if (typeof strategy === "function") {
    strategy(request);
    return;
  }
  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));
  const handlerGroups = groupHandlersByType(handlers2);
  const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;
  const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getScoreForGraphQLHandler(parsedGraphQLQuery) : getScoreForRestHandler());
  const handlerSuggestion = suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : "";
  const publicUrl = getPublicUrlFromRequest(request);
  const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;
  const messageTemplate = [
    `captured a request without a matching request handler:`,
    `  \u2022 ${requestHeader}`,
    handlerSuggestion,
    `If you still wish to intercept this unhandled request, please create a request handler for it.
Read more: https://mswjs.io/docs/getting-started/mocks`
  ].filter(Boolean);
  const message = messageTemplate.join("\n\n");
  switch (strategy) {
    case "error": {
      devUtils.error("Error: %s", message);
      throw new Error('Cannot bypass a request when using the "error" strategy for the "onUnhandledRequest" option.');
    }
    case "warn": {
      devUtils.warn("Warning: %s", message);
      break;
    }
    case "bypass":
      break;
    default:
      throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy "%s". Please provide one of the supported strategies ("bypass", "warn", "error") or a custom callback function as the value of the "onUnhandledRequest" option.', strategy));
  }
}
function readResponseCookies(request, response2) {
  lib$12.store.add(Object.assign(Object.assign({}, request), { url: request.url.toString() }), response2);
  lib$12.store.persist();
}
function handleRequest(request, handlers2, options, emitter, handleRequestOptions) {
  var _a, _b, _c;
  return __awaiter(this, void 0, void 0, function* () {
    emitter.emit("request:start", request);
    if (request.headers.get("x-msw-bypass")) {
      emitter.emit("request:end", request);
      (_a = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _a === void 0 ? void 0 : _a.call(handleRequestOptions, request);
      return;
    }
    const lookupResult = yield getResponse(request, handlers2, handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.resolutionContext);
    const { handler, response: response2 } = lookupResult;
    if (!handler) {
      onUnhandledRequest(request, handlers2, options.onUnhandledRequest);
      emitter.emit("request:unhandled", request);
      emitter.emit("request:end", request);
      (_b = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _b === void 0 ? void 0 : _b.call(handleRequestOptions, request);
      return;
    }
    if (!response2) {
      devUtils.warn("Expected a mocking resolver function to return a mocked response Object, but got: %s. Original response is going to be used instead.", response2);
      emitter.emit("request:end", request);
      (_c = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _c === void 0 ? void 0 : _c.call(handleRequestOptions, request);
      return;
    }
    readResponseCookies(request, response2);
    emitter.emit("request:match", request);
    return new Promise((resolve) => {
      var _a2, _b2, _c2;
      const requiredLookupResult = lookupResult;
      const transformedResponse = ((_a2 = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.transformResponse) === null || _a2 === void 0 ? void 0 : _a2.call(handleRequestOptions, response2)) || response2;
      (_b2 = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onMockedResponse) === null || _b2 === void 0 ? void 0 : _b2.call(handleRequestOptions, transformedResponse, requiredLookupResult);
      setTimeout(() => {
        var _a3;
        (_a3 = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onMockedResponseSent) === null || _a3 === void 0 ? void 0 : _a3.call(handleRequestOptions, transformedResponse, requiredLookupResult);
        emitter.emit("request:end", request);
        resolve(transformedResponse);
      }, (_c2 = response2.delay) !== null && _c2 !== void 0 ? _c2 : 0);
    });
  });
}
var createRequestListener = (context, options) => {
  return (event, message) => __awaiter(void 0, void 0, void 0, function* () {
    const channel = createBroadcastChannel(event);
    try {
      const request = parseWorkerRequest(message.payload);
      yield handleRequest(request, context.requestHandlers, options, context.emitter, {
        transformResponse(response2) {
          return Object.assign(Object.assign({}, response2), { headers: response2.headers.all() });
        },
        onBypassResponse() {
          return channel.send({
            type: "MOCK_NOT_FOUND"
          });
        },
        onMockedResponse(response2) {
          channel.send({
            type: "MOCK_SUCCESS",
            payload: response2
          });
        },
        onMockedResponseSent(response2, { handler, publicRequest, parsedRequest }) {
          if (!options.quiet) {
            handler.log(publicRequest, response2, handler, parsedRequest);
          }
        }
      });
    } catch (error2) {
      if (error2 instanceof NetworkError) {
        return channel.send({
          type: "NETWORK_ERROR",
          payload: {
            name: error2.name,
            message: error2.message
          }
        });
      }
      channel.send({
        type: "INTERNAL_ERROR",
        payload: {
          status: 500,
          body: JSON.stringify({
            errorType: error2.constructor.name,
            message: error2.message,
            location: error2.stack
          })
        }
      });
    }
  });
};
function requestIntegrityCheck(context, serviceWorker) {
  return __awaiter(this, void 0, void 0, function* () {
    context.workerChannel.send("INTEGRITY_CHECK_REQUEST");
    const { payload: actualChecksum } = yield context.events.once("INTEGRITY_CHECK_RESPONSE");
    if (actualChecksum !== "f0a916b13c8acc2b526a03a6d26df85f") {
      throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${"f0a916b13c8acc2b526a03a6d26df85f"}).`);
    }
    return serviceWorker;
  });
}
function deferNetworkRequestsUntil(predicatePromise) {
  const originalXhrSend = window.XMLHttpRequest.prototype.send;
  window.XMLHttpRequest.prototype.send = function(...args) {
    until(() => predicatePromise).then(() => {
      window.XMLHttpRequest.prototype.send = originalXhrSend;
      this.send(...args);
    });
  };
  const originalFetch = window.fetch;
  window.fetch = (...args) => __awaiter(this, void 0, void 0, function* () {
    yield until(() => predicatePromise);
    window.fetch = originalFetch;
    return window.fetch(...args);
  });
}
function createResponseListener(context) {
  return (_, message) => {
    var _a;
    const { payload: responseJson } = message;
    if ((_a = responseJson.type) === null || _a === void 0 ? void 0 : _a.includes("opaque")) {
      return;
    }
    const response2 = new Response(responseJson.body || null, responseJson);
    const isMockedResponse = response2.headers.get("x-powered-by") === "msw";
    if (isMockedResponse) {
      context.emitter.emit("response:mocked", response2, responseJson.requestId);
    } else {
      context.emitter.emit("response:bypass", response2, responseJson.requestId);
    }
  };
}
function validateWorkerScope(registration, options) {
  if (!(options === null || options === void 0 ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {
    devUtils.warn(`Cannot intercept requests on this page because it's outside of the worker's scope ("${registration.scope}"). If you wish to mock API requests on this page, you must resolve this scope issue.

- (Recommended) Register the worker at the root level ("/") of your application.
- Set the "Service-Worker-Allowed" response header to allow out-of-scope workers.`);
  }
}
var createStartHandler = (context) => {
  return function start(options, customOptions) {
    const startWorkerInstance = () => __awaiter(this, void 0, void 0, function* () {
      context.events.removeAllListeners();
      context.workerChannel.on("REQUEST", createRequestListener(context, options));
      context.workerChannel.on("RESPONSE", createResponseListener(context));
      const instance = yield getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);
      const [worker2, registration] = instance;
      if (!worker2) {
        const missingWorkerMessage = (customOptions === null || customOptions === void 0 ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(`Failed to locate the Service Worker registration using a custom "findWorker" predicate.

Please ensure that the custom predicate properly locates the Service Worker registration at "%s".
More details: https://mswjs.io/docs/api/setup-worker/start#findworker
`, options.serviceWorker.url) : devUtils.formatMessage(`Failed to locate the Service Worker registration.

This most likely means that the worker script URL "%s" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.

Please consider using a custom "serviceWorker.url" option to point to the actual worker script location, or a custom "findWorker" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);
        throw new Error(missingWorkerMessage);
      }
      context.worker = worker2;
      context.registration = registration;
      context.events.addListener(window, "beforeunload", () => {
        if (worker2.state !== "redundant") {
          context.workerChannel.send("CLIENT_CLOSED");
        }
        window.clearInterval(context.keepAliveInterval);
      });
      const [integrityError] = yield until(() => requestIntegrityCheck(context, worker2));
      if (integrityError) {
        devUtils.error(`Detected outdated Service Worker: ${integrityError.message}

The mocking is still enabled, but it's highly recommended that you update your Service Worker by running:

$ npx msw init <PUBLIC_DIR>

This is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.
If this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);
      }
      yield enableMocking(context, options).catch((err) => {
        throw new Error(`Failed to enable mocking: ${err === null || err === void 0 ? void 0 : err.message}`);
      });
      context.keepAliveInterval = window.setInterval(() => context.workerChannel.send("KEEPALIVE_REQUEST"), 5e3);
      validateWorkerScope(registration, context.startOptions);
      return registration;
    });
    const workerRegistration = startWorkerInstance();
    if (options.waitUntilReady) {
      deferNetworkRequestsUntil(workerRegistration);
    }
    return workerRegistration;
  };
};
function printStopMessage(args = {}) {
  if (args.quiet) {
    return;
  }
  console.log(`%c${devUtils.formatMessage("Mocking disabled.")}`, "color:orangered;font-weight:bold;");
}
var createStop = (context) => {
  return function stop() {
    var _a;
    context.workerChannel.send("MOCK_DEACTIVATE");
    window.clearInterval(context.keepAliveInterval);
    printStopMessage({ quiet: (_a = context.startOptions) === null || _a === void 0 ? void 0 : _a.quiet });
  };
};
function use(currentHandlers, ...handlers2) {
  currentHandlers.unshift(...handlers2);
}
function restoreHandlers(handlers2) {
  handlers2.forEach((handler) => {
    handler.markAsSkipped(false);
  });
}
function resetHandlers(initialHandlers, ...nextHandlers) {
  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];
}
var DEFAULT_START_OPTIONS = {
  serviceWorker: {
    url: "/mockServiceWorker.js",
    options: null
  },
  quiet: false,
  waitUntilReady: true,
  onUnhandledRequest: "warn",
  findWorker(scriptURL, mockServiceWorkerUrl) {
    return scriptURL === mockServiceWorkerUrl;
  }
};
function resolveStartOptions(initialOptions) {
  return mergeRight(DEFAULT_START_OPTIONS, initialOptions || {});
}
function prepareStartHandler(handler, context) {
  return (initialOptions) => {
    context.startOptions = resolveStartOptions(initialOptions);
    return handler(context.startOptions, initialOptions || {});
  };
}
var lib3 = {};
var createInterceptor$1 = {};
Object.defineProperty(createInterceptor$1, "__esModule", { value: true });
createInterceptor$1.createInterceptor = void 0;
var strict_event_emitter_1$1 = lib$3;
function createInterceptor(options) {
  var observer = new strict_event_emitter_1$1.StrictEventEmitter();
  var cleanupFns = [];
  return {
    apply: function() {
      cleanupFns = options.modules.map(function(interceptor) {
        return interceptor(observer, options.resolver);
      });
    },
    on: function(event, listener) {
      observer.addListener(event, listener);
    },
    restore: function() {
      observer.removeAllListeners();
      if (cleanupFns.length === 0) {
        throw new Error('Failed to restore patched modules: no patches found. Did you forget to run ".apply()"?');
      }
      cleanupFns.forEach(function(restore) {
        return restore();
      });
    }
  };
}
createInterceptor$1.createInterceptor = createInterceptor;
var remote = {};
var toIsoResponse$1 = {};
Object.defineProperty(toIsoResponse$1, "__esModule", { value: true });
toIsoResponse$1.toIsoResponse = void 0;
var headers_utils_1$3 = lib$1;
function toIsoResponse(response2) {
  return {
    status: response2.status || 200,
    statusText: response2.statusText || "OK",
    headers: headers_utils_1$3.objectToHeaders(response2.headers || {}),
    body: response2.body
  };
}
toIsoResponse$1.toIsoResponse = toIsoResponse;
var __assign$1 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var __awaiter$2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body2) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body2.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read$12 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
Object.defineProperty(remote, "__esModule", { value: true });
remote.createRemoteResolver = remote.createRemoteInterceptor = void 0;
var headers_utils_1$2 = lib$1;
var outvariant_1 = lib2;
var strict_event_emitter_1 = lib$3;
var createInterceptor_1 = createInterceptor$1;
var toIsoResponse_1$2 = toIsoResponse$1;
function requestReviver(key, value) {
  switch (key) {
    case "url":
      return new URL(value);
    case "headers":
      return new headers_utils_1$2.Headers(value);
    default:
      return value;
  }
}
function createRemoteInterceptor(options) {
  outvariant_1.invariant(process.connected, "Failed to create a remote interceptor: the current process (%s) does not have a parent. Please make sure you're spawning this process as a child process in order to use remote request interception.", process.pid);
  if (typeof process.send === "undefined") {
    throw new Error("Failed to create a remote interceptor: the current process (" + process.pid + `) does not have the IPC enabled. Please make sure you're spawning this process with the "ipc" stdio value set:

spawn('node', ['module.js'], { stdio: ['ipc'] })`);
  }
  var handleParentMessage;
  var interceptor = createInterceptor_1.createInterceptor(__assign$1(__assign$1({}, options), { resolver: function(request) {
    var _a;
    var serializedRequest = JSON.stringify(request);
    (_a = process.send) === null || _a === void 0 ? void 0 : _a.call(process, "request:" + serializedRequest);
    return new Promise(function(resolve) {
      handleParentMessage = function(message) {
        if (typeof message !== "string") {
          return;
        }
        if (message.startsWith("response:" + request.id)) {
          var _a2 = __read$12(message.match(/^response:.+?:(.+)$/) || [], 2), responseString = _a2[1];
          if (!responseString) {
            return resolve();
          }
          var mockedResponse = JSON.parse(responseString);
          return resolve(mockedResponse);
        }
      };
      process.addListener("message", handleParentMessage);
    });
  } }));
  return __assign$1(__assign$1({}, interceptor), { restore: function() {
    interceptor.restore();
    process.removeListener("message", handleParentMessage);
  } });
}
remote.createRemoteInterceptor = createRemoteInterceptor;
function createRemoteResolver(options) {
  var _this = this;
  var observer = new strict_event_emitter_1.StrictEventEmitter();
  var handleChildMessage = function(message) {
    return __awaiter$2(_this, void 0, void 0, function() {
      var _a, requestString, isoRequest_1, mockedResponse_1, serializedResponse;
      return __generator$2(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (typeof message !== "string") {
              return [2];
            }
            if (!message.startsWith("request:"))
              return [3, 2];
            _a = __read$12(message.match(/^request:(.+)$/) || [], 2), requestString = _a[1];
            if (!requestString) {
              return [2];
            }
            isoRequest_1 = JSON.parse(requestString, requestReviver);
            observer.emit("request", isoRequest_1);
            return [
              4,
              options.resolver(isoRequest_1, void 0)
            ];
          case 1:
            mockedResponse_1 = _b.sent();
            serializedResponse = JSON.stringify(mockedResponse_1);
            options.process.send("response:" + isoRequest_1.id + ":" + serializedResponse, function(error2) {
              if (error2) {
                return;
              }
              if (mockedResponse_1) {
                observer.emit("response", isoRequest_1, toIsoResponse_1$2.toIsoResponse(mockedResponse_1));
              }
            });
            _b.label = 2;
          case 2:
            return [2];
        }
      });
    });
  };
  var cleanup = function() {
    options.process.removeListener("message", handleChildMessage);
  };
  options.process.addListener("message", handleChildMessage);
  options.process.addListener("disconnect", cleanup);
  options.process.addListener("error", cleanup);
  options.process.addListener("exit", cleanup);
  return {
    on: function(event, listener) {
      observer.addListener(event, listener);
    }
  };
}
remote.createRemoteResolver = createRemoteResolver;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCleanUrl = void 0;
  __exportStar(createInterceptor$1, exports);
  __exportStar(remote, exports);
  var getCleanUrl_1 = getCleanUrl$1;
  Object.defineProperty(exports, "getCleanUrl", { enumerable: true, get: function() {
    return getCleanUrl_1.getCleanUrl;
  } });
})(lib3);
var fetch3 = {};
var uuid = {};
Object.defineProperty(uuid, "__esModule", { value: true });
uuid.uuidv4 = void 0;
function uuidv4$1() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0;
    var v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
uuid.uuidv4 = uuidv4$1;
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body2) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body2.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(fetch3, "__esModule", { value: true });
var interceptFetch_1 = fetch3.interceptFetch = void 0;
var headers_utils_1$1 = lib$1;
var toIsoResponse_1$1 = toIsoResponse$1;
var uuid_1$1 = uuid;
var debug$1 = (0, import_debug.default)("fetch");
var interceptFetch = function(observer, resolver) {
  var pureFetch = window.fetch;
  debug$1('replacing "window.fetch"...');
  window.fetch = function(input, init) {
    return __awaiter$1(void 0, void 0, void 0, function() {
      var ref, url, method, isoRequest, response2, isomorphicResponse;
      var _a;
      return __generator$1(this, function(_b) {
        switch (_b.label) {
          case 0:
            ref = new Request(input, init);
            url = typeof input === "string" ? input : input.url;
            method = (init === null || init === void 0 ? void 0 : init.method) || "GET";
            debug$1("[%s] %s", method, url);
            _a = {
              id: uuid_1$1.uuidv4(),
              url: new URL(url, location.origin),
              method,
              headers: new headers_utils_1$1.Headers((init === null || init === void 0 ? void 0 : init.headers) || {})
            };
            return [4, ref.text()];
          case 1:
            isoRequest = (_a.body = _b.sent(), _a);
            debug$1("isomorphic request", isoRequest);
            observer.emit("request", isoRequest);
            debug$1("awaiting for the mocked response...");
            return [4, resolver(isoRequest, ref)];
          case 2:
            response2 = _b.sent();
            debug$1("mocked response", response2);
            if (response2) {
              isomorphicResponse = toIsoResponse_1$1.toIsoResponse(response2);
              debug$1("derived isomorphic response", isomorphicResponse);
              observer.emit("response", isoRequest, isomorphicResponse);
              return [2, new Response(response2.body, __assign(__assign({}, isomorphicResponse), {
                headers: headers_utils_1$1.flattenHeadersObject(response2.headers || {})
              }))];
            }
            debug$1("no mocked response found, bypassing...");
            return [2, pureFetch(input, init).then(function(response3) {
              return __awaiter$1(void 0, void 0, void 0, function() {
                var _a2, _b2, _c;
                return __generator$1(this, function(_d) {
                  switch (_d.label) {
                    case 0:
                      debug$1("original fetch performed", response3);
                      _b2 = (_a2 = observer).emit;
                      _c = [
                        "response",
                        isoRequest
                      ];
                      return [4, normalizeFetchResponse(response3)];
                    case 1:
                      _b2.apply(_a2, _c.concat([_d.sent()]));
                      return [2, response3];
                  }
                });
              });
            })];
        }
      });
    });
  };
  return function() {
    debug$1("restoring modules...");
    window.fetch = pureFetch;
  };
};
interceptFetch_1 = fetch3.interceptFetch = interceptFetch;
function normalizeFetchResponse(response2) {
  return __awaiter$1(this, void 0, void 0, function() {
    var _a;
    return __generator$1(this, function(_b) {
      switch (_b.label) {
        case 0:
          _a = {
            status: response2.status,
            statusText: response2.statusText,
            headers: headers_utils_1$1.objectToHeaders(headers_utils_1$1.headersToObject(response2.headers))
          };
          return [4, response2.text()];
        case 1:
          return [2, (_a.body = _b.sent(), _a)];
      }
    });
  });
}
var XMLHttpRequest = {};
var XMLHttpRequestOverride = {};
var domParser = {};
var conventions$2 = {};
function freeze(object, oc) {
  if (oc === void 0) {
    oc = Object;
  }
  return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
}
var MIME_TYPE = freeze({
  HTML: "text/html",
  isHTML: function(value) {
    return value === MIME_TYPE.HTML;
  },
  XML_APPLICATION: "application/xml",
  XML_TEXT: "text/xml",
  XML_XHTML_APPLICATION: "application/xhtml+xml",
  XML_SVG_IMAGE: "image/svg+xml"
});
var NAMESPACE$3 = freeze({
  HTML: "http://www.w3.org/1999/xhtml",
  isHTML: function(uri) {
    return uri === NAMESPACE$3.HTML;
  },
  SVG: "http://www.w3.org/2000/svg",
  XML: "http://www.w3.org/XML/1998/namespace",
  XMLNS: "http://www.w3.org/2000/xmlns/"
});
conventions$2.freeze = freeze;
conventions$2.MIME_TYPE = MIME_TYPE;
conventions$2.NAMESPACE = NAMESPACE$3;
var entities$1 = {};
(function(exports) {
  var freeze2 = conventions$2.freeze;
  exports.XML_ENTITIES = freeze2({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' });
  exports.HTML_ENTITIES = freeze2({
    lt: "<",
    gt: ">",
    amp: "&",
    quot: '"',
    apos: "'",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    times: "\xD7",
    divide: "\xF7",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    "int": "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    euro: "\u20AC",
    trade: "\u2122",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  });
  exports.entityMap = exports.HTML_ENTITIES;
})(entities$1);
var sax$1 = {};
var NAMESPACE$2 = conventions$2.NAMESPACE;
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
var S_TAG = 0;
var S_ATTR = 1;
var S_ATTR_SPACE = 2;
var S_EQ = 3;
var S_ATTR_NOQUOT_VALUE = 4;
var S_ATTR_END = 5;
var S_TAG_SPACE = 6;
var S_TAG_CLOSE = 7;
function ParseError$1(message, locator) {
  this.message = message;
  this.locator = locator;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ParseError$1);
}
ParseError$1.prototype = new Error();
ParseError$1.prototype.name = ParseError$1.name;
function XMLReader$1() {
}
XMLReader$1.prototype = {
  parse: function(source, defaultNSMap, entityMap) {
    var domBuilder = this.domBuilder;
    domBuilder.startDocument();
    _copy(defaultNSMap, defaultNSMap = {});
    parse3(
      source,
      defaultNSMap,
      entityMap,
      domBuilder,
      this.errorHandler
    );
    domBuilder.endDocument();
  }
};
function parse3(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
  function fixedFromCharCode(code) {
    if (code > 65535) {
      code -= 65536;
      var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    } else {
      return String.fromCharCode(code);
    }
  }
  function entityReplacer(a2) {
    var k = a2.slice(1, -1);
    if (k in entityMap) {
      return entityMap[k];
    } else if (k.charAt(0) === "#") {
      return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
    } else {
      errorHandler.error("entity not found:" + a2);
      return a2;
    }
  }
  function appendText(end2) {
    if (end2 > start) {
      var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
      locator && position2(start);
      domBuilder.characters(xt, 0, end2 - start);
      start = end2;
    }
  }
  function position2(p, m) {
    while (p >= lineEnd && (m = linePattern.exec(source))) {
      lineStart = m.index;
      lineEnd = lineStart + m[0].length;
      locator.lineNumber++;
    }
    locator.columnNumber = p - lineStart + 1;
  }
  var lineStart = 0;
  var lineEnd = 0;
  var linePattern = /.*(?:\r\n?|\n)|.*$/g;
  var locator = domBuilder.locator;
  var parseStack = [{ currentNSMap: defaultNSMapCopy }];
  var closeMap = {};
  var start = 0;
  while (true) {
    try {
      var tagStart = source.indexOf("<", start);
      if (tagStart < 0) {
        if (!source.substr(start).match(/^\s*$/)) {
          var doc = domBuilder.doc;
          var text2 = doc.createTextNode(source.substr(start));
          doc.appendChild(text2);
          domBuilder.currentElement = text2;
        }
        return;
      }
      if (tagStart > start) {
        appendText(tagStart);
      }
      switch (source.charAt(tagStart + 1)) {
        case "/":
          var end = source.indexOf(">", tagStart + 3);
          var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
          var config = parseStack.pop();
          if (end < 0) {
            tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
            errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
            end = tagStart + 1 + tagName.length;
          } else if (tagName.match(/\s</)) {
            tagName = tagName.replace(/[\s<].*/, "");
            errorHandler.error("end tag name: " + tagName + " maybe not complete");
            end = tagStart + 1 + tagName.length;
          }
          var localNSMap = config.localNSMap;
          var endMatch = config.tagName == tagName;
          var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
          if (endIgnoreCaseMach) {
            domBuilder.endElement(config.uri, config.localName, tagName);
            if (localNSMap) {
              for (var prefix in localNSMap) {
                domBuilder.endPrefixMapping(prefix);
              }
            }
            if (!endMatch) {
              errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
            }
          } else {
            parseStack.push(config);
          }
          end++;
          break;
        case "?":
          locator && position2(tagStart);
          end = parseInstruction(source, tagStart, domBuilder);
          break;
        case "!":
          locator && position2(tagStart);
          end = parseDCC(source, tagStart, domBuilder, errorHandler);
          break;
        default:
          locator && position2(tagStart);
          var el = new ElementAttributes();
          var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
          var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
          var len = el.length;
          if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
            el.closed = true;
            if (!entityMap.nbsp) {
              errorHandler.warning("unclosed xml attribute");
            }
          }
          if (locator && len) {
            var locator2 = copyLocator(locator, {});
            for (var i = 0; i < len; i++) {
              var a = el[i];
              position2(a.offset);
              a.locator = copyLocator(locator, {});
            }
            domBuilder.locator = locator2;
            if (appendElement$1(el, domBuilder, currentNSMap)) {
              parseStack.push(el);
            }
            domBuilder.locator = locator;
          } else {
            if (appendElement$1(el, domBuilder, currentNSMap)) {
              parseStack.push(el);
            }
          }
          if (NAMESPACE$2.isHTML(el.uri) && !el.closed) {
            end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
          } else {
            end++;
          }
      }
    } catch (e) {
      if (e instanceof ParseError$1) {
        throw e;
      }
      errorHandler.error("element parse error: " + e);
      end = -1;
    }
    if (end > start) {
      start = end;
    } else {
      appendText(Math.max(tagStart, start) + 1);
    }
  }
}
function copyLocator(f, t) {
  t.lineNumber = f.lineNumber;
  t.columnNumber = f.columnNumber;
  return t;
}
function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
  function addAttribute(qname, value2, startIndex) {
    if (qname in el.attributeNames)
      errorHandler.fatalError("Attribute " + qname + " redefined");
    el.addValue(qname, value2, startIndex);
  }
  var attrName;
  var value;
  var p = ++start;
  var s = S_TAG;
  while (true) {
    var c = source.charAt(p);
    switch (c) {
      case "=":
        if (s === S_ATTR) {
          attrName = source.slice(start, p);
          s = S_EQ;
        } else if (s === S_ATTR_SPACE) {
          s = S_EQ;
        } else {
          throw new Error("attribute equal must after attrName");
        }
        break;
      case "'":
      case '"':
        if (s === S_EQ || s === S_ATTR) {
          if (s === S_ATTR) {
            errorHandler.warning('attribute value must after "="');
            attrName = source.slice(start, p);
          }
          start = p + 1;
          p = source.indexOf(c, start);
          if (p > 0) {
            value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
            addAttribute(attrName, value, start - 1);
            s = S_ATTR_END;
          } else {
            throw new Error("attribute value no end '" + c + "' match");
          }
        } else if (s == S_ATTR_NOQUOT_VALUE) {
          value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
          addAttribute(attrName, value, start);
          errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
          start = p + 1;
          s = S_ATTR_END;
        } else {
          throw new Error('attribute value must after "="');
        }
        break;
      case "/":
        switch (s) {
          case S_TAG:
            el.setTagName(source.slice(start, p));
          case S_ATTR_END:
          case S_TAG_SPACE:
          case S_TAG_CLOSE:
            s = S_TAG_CLOSE;
            el.closed = true;
          case S_ATTR_NOQUOT_VALUE:
          case S_ATTR:
          case S_ATTR_SPACE:
            break;
          default:
            throw new Error("attribute invalid close char('/')");
        }
        break;
      case "":
        errorHandler.error("unexpected end of input");
        if (s == S_TAG) {
          el.setTagName(source.slice(start, p));
        }
        return p;
      case ">":
        switch (s) {
          case S_TAG:
            el.setTagName(source.slice(start, p));
          case S_ATTR_END:
          case S_TAG_SPACE:
          case S_TAG_CLOSE:
            break;
          case S_ATTR_NOQUOT_VALUE:
          case S_ATTR:
            value = source.slice(start, p);
            if (value.slice(-1) === "/") {
              el.closed = true;
              value = value.slice(0, -1);
            }
          case S_ATTR_SPACE:
            if (s === S_ATTR_SPACE) {
              value = attrName;
            }
            if (s == S_ATTR_NOQUOT_VALUE) {
              errorHandler.warning('attribute "' + value + '" missed quot(")!');
              addAttribute(attrName, value.replace(/&#?\w+;/g, entityReplacer), start);
            } else {
              if (!NAMESPACE$2.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
              }
              addAttribute(value, value, start);
            }
            break;
          case S_EQ:
            throw new Error("attribute value missed!!");
        }
        return p;
      case "\x80":
        c = " ";
      default:
        if (c <= " ") {
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start, p));
              s = S_TAG_SPACE;
              break;
            case S_ATTR:
              attrName = source.slice(start, p);
              s = S_ATTR_SPACE;
              break;
            case S_ATTR_NOQUOT_VALUE:
              var value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
              errorHandler.warning('attribute "' + value + '" missed quot(")!!');
              addAttribute(attrName, value, start);
            case S_ATTR_END:
              s = S_TAG_SPACE;
              break;
          }
        } else {
          switch (s) {
            case S_ATTR_SPACE:
              el.tagName;
              if (!NAMESPACE$2.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
              }
              addAttribute(attrName, attrName, start);
              start = p;
              s = S_ATTR;
              break;
            case S_ATTR_END:
              errorHandler.warning('attribute space is required"' + attrName + '"!!');
            case S_TAG_SPACE:
              s = S_ATTR;
              start = p;
              break;
            case S_EQ:
              s = S_ATTR_NOQUOT_VALUE;
              start = p;
              break;
            case S_TAG_CLOSE:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
        }
    }
    p++;
  }
}
function appendElement$1(el, domBuilder, currentNSMap) {
  var tagName = el.tagName;
  var localNSMap = null;
  var i = el.length;
  while (i--) {
    var a = el[i];
    var qName = a.qName;
    var value = a.value;
    var nsp = qName.indexOf(":");
    if (nsp > 0) {
      var prefix = a.prefix = qName.slice(0, nsp);
      var localName = qName.slice(nsp + 1);
      var nsPrefix = prefix === "xmlns" && localName;
    } else {
      localName = qName;
      prefix = null;
      nsPrefix = qName === "xmlns" && "";
    }
    a.localName = localName;
    if (nsPrefix !== false) {
      if (localNSMap == null) {
        localNSMap = {};
        _copy(currentNSMap, currentNSMap = {});
      }
      currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
      a.uri = NAMESPACE$2.XMLNS;
      domBuilder.startPrefixMapping(nsPrefix, value);
    }
  }
  var i = el.length;
  while (i--) {
    a = el[i];
    var prefix = a.prefix;
    if (prefix) {
      if (prefix === "xml") {
        a.uri = NAMESPACE$2.XML;
      }
      if (prefix !== "xmlns") {
        a.uri = currentNSMap[prefix || ""];
      }
    }
  }
  var nsp = tagName.indexOf(":");
  if (nsp > 0) {
    prefix = el.prefix = tagName.slice(0, nsp);
    localName = el.localName = tagName.slice(nsp + 1);
  } else {
    prefix = null;
    localName = el.localName = tagName;
  }
  var ns = el.uri = currentNSMap[prefix || ""];
  domBuilder.startElement(ns, localName, tagName, el);
  if (el.closed) {
    domBuilder.endElement(ns, localName, tagName);
    if (localNSMap) {
      for (prefix in localNSMap) {
        domBuilder.endPrefixMapping(prefix);
      }
    }
  } else {
    el.currentNSMap = currentNSMap;
    el.localNSMap = localNSMap;
    return true;
  }
}
function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
  if (/^(?:script|textarea)$/i.test(tagName)) {
    var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
    var text2 = source.substring(elStartEnd + 1, elEndStart);
    if (/[&<]/.test(text2)) {
      if (/^script$/i.test(tagName)) {
        domBuilder.characters(text2, 0, text2.length);
        return elEndStart;
      }
      text2 = text2.replace(/&#?\w+;/g, entityReplacer);
      domBuilder.characters(text2, 0, text2.length);
      return elEndStart;
    }
  }
  return elStartEnd + 1;
}
function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
  var pos = closeMap[tagName];
  if (pos == null) {
    pos = source.lastIndexOf("</" + tagName + ">");
    if (pos < elStartEnd) {
      pos = source.lastIndexOf("</" + tagName);
    }
    closeMap[tagName] = pos;
  }
  return pos < elStartEnd;
}
function _copy(source, target) {
  for (var n in source) {
    target[n] = source[n];
  }
}
function parseDCC(source, start, domBuilder, errorHandler) {
  var next = source.charAt(start + 2);
  switch (next) {
    case "-":
      if (source.charAt(start + 3) === "-") {
        var end = source.indexOf("-->", start + 4);
        if (end > start) {
          domBuilder.comment(source, start + 4, end - start - 4);
          return end + 3;
        } else {
          errorHandler.error("Unclosed comment");
          return -1;
        }
      } else {
        return -1;
      }
    default:
      if (source.substr(start + 3, 6) == "CDATA[") {
        var end = source.indexOf("]]>", start + 9);
        domBuilder.startCDATA();
        domBuilder.characters(source, start + 9, end - start - 9);
        domBuilder.endCDATA();
        return end + 3;
      }
      var matchs = split(source, start);
      var len = matchs.length;
      if (len > 1 && /!doctype/i.test(matchs[0][0])) {
        var name = matchs[1][0];
        var pubid = false;
        var sysid = false;
        if (len > 3) {
          if (/^public$/i.test(matchs[2][0])) {
            pubid = matchs[3][0];
            sysid = len > 4 && matchs[4][0];
          } else if (/^system$/i.test(matchs[2][0])) {
            sysid = matchs[3][0];
          }
        }
        var lastMatch = matchs[len - 1];
        domBuilder.startDTD(name, pubid, sysid);
        domBuilder.endDTD();
        return lastMatch.index + lastMatch[0].length;
      }
  }
  return -1;
}
function parseInstruction(source, start, domBuilder) {
  var end = source.indexOf("?>", start);
  if (end) {
    var match2 = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    if (match2) {
      match2[0].length;
      domBuilder.processingInstruction(match2[1], match2[2]);
      return end + 2;
    } else {
      return -1;
    }
  }
  return -1;
}
function ElementAttributes() {
  this.attributeNames = {};
}
ElementAttributes.prototype = {
  setTagName: function(tagName) {
    if (!tagNamePattern.test(tagName)) {
      throw new Error("invalid tagName:" + tagName);
    }
    this.tagName = tagName;
  },
  addValue: function(qName, value, offset) {
    if (!tagNamePattern.test(qName)) {
      throw new Error("invalid attribute:" + qName);
    }
    this.attributeNames[qName] = this.length;
    this[this.length++] = { qName, value, offset };
  },
  length: 0,
  getLocalName: function(i) {
    return this[i].localName;
  },
  getLocator: function(i) {
    return this[i].locator;
  },
  getQName: function(i) {
    return this[i].qName;
  },
  getURI: function(i) {
    return this[i].uri;
  },
  getValue: function(i) {
    return this[i].value;
  }
};
function split(source, start) {
  var match2;
  var buf = [];
  var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  reg.lastIndex = start;
  reg.exec(source);
  while (match2 = reg.exec(source)) {
    buf.push(match2);
    if (match2[1])
      return buf;
  }
}
sax$1.XMLReader = XMLReader$1;
sax$1.ParseError = ParseError$1;
var dom = {};
var conventions$1 = conventions$2;
var NAMESPACE$1 = conventions$1.NAMESPACE;
function notEmptyString(input) {
  return input !== "";
}
function splitOnASCIIWhitespace(input) {
  return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
}
function orderedSetReducer(current, element) {
  if (!current.hasOwnProperty(element)) {
    current[element] = true;
  }
  return current;
}
function toOrderedSet(input) {
  if (!input)
    return [];
  var list = splitOnASCIIWhitespace(input);
  return Object.keys(list.reduce(orderedSetReducer, {}));
}
function arrayIncludes(list) {
  return function(element) {
    return list && list.indexOf(element) !== -1;
  };
}
function copy(src, dest) {
  for (var p in src) {
    dest[p] = src[p];
  }
}
function _extends(Class, Super) {
  var pt = Class.prototype;
  if (!(pt instanceof Super)) {
    let t = function() {
    };
    t.prototype = Super.prototype;
    t = new t();
    copy(pt, t);
    Class.prototype = pt = t;
  }
  if (pt.constructor != Class) {
    if (typeof Class != "function") {
      console.error("unknow Class:" + Class);
    }
    pt.constructor = Class;
  }
}
var NodeType = {};
var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
var TEXT_NODE = NodeType.TEXT_NODE = 3;
var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
var ExceptionCode = {};
var ExceptionMessage = {};
ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
function DOMException(code, message) {
  if (message instanceof Error) {
    var error2 = message;
  } else {
    error2 = this;
    Error.call(this, ExceptionMessage[code]);
    this.message = ExceptionMessage[code];
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, DOMException);
  }
  error2.code = code;
  if (message)
    this.message = this.message + ": " + message;
  return error2;
}
DOMException.prototype = Error.prototype;
copy(ExceptionCode, DOMException);
function NodeList() {
}
NodeList.prototype = {
  length: 0,
  item: function(index2) {
    return this[index2] || null;
  },
  toString: function(isHTML, nodeFilter) {
    for (var buf = [], i = 0; i < this.length; i++) {
      serializeToString(this[i], buf, isHTML, nodeFilter);
    }
    return buf.join("");
  }
};
function LiveNodeList(node, refresh) {
  this._node = node;
  this._refresh = refresh;
  _updateLiveList(this);
}
function _updateLiveList(list) {
  var inc = list._node._inc || list._node.ownerDocument._inc;
  if (list._inc != inc) {
    var ls = list._refresh(list._node);
    __set__(list, "length", ls.length);
    copy(ls, list);
    list._inc = inc;
  }
}
LiveNodeList.prototype.item = function(i) {
  _updateLiveList(this);
  return this[i];
};
_extends(LiveNodeList, NodeList);
function NamedNodeMap() {
}
function _findNodeIndex(list, node) {
  var i = list.length;
  while (i--) {
    if (list[i] === node) {
      return i;
    }
  }
}
function _addNamedNode(el, list, newAttr, oldAttr) {
  if (oldAttr) {
    list[_findNodeIndex(list, oldAttr)] = newAttr;
  } else {
    list[list.length++] = newAttr;
  }
  if (el) {
    newAttr.ownerElement = el;
    var doc = el.ownerDocument;
    if (doc) {
      oldAttr && _onRemoveAttribute(doc, el, oldAttr);
      _onAddAttribute(doc, el, newAttr);
    }
  }
}
function _removeNamedNode(el, list, attr) {
  var i = _findNodeIndex(list, attr);
  if (i >= 0) {
    var lastIndex = list.length - 1;
    while (i < lastIndex) {
      list[i] = list[++i];
    }
    list.length = lastIndex;
    if (el) {
      var doc = el.ownerDocument;
      if (doc) {
        _onRemoveAttribute(doc, el, attr);
        attr.ownerElement = null;
      }
    }
  } else {
    throw DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
  }
}
NamedNodeMap.prototype = {
  length: 0,
  item: NodeList.prototype.item,
  getNamedItem: function(key) {
    var i = this.length;
    while (i--) {
      var attr = this[i];
      if (attr.nodeName == key) {
        return attr;
      }
    }
  },
  setNamedItem: function(attr) {
    var el = attr.ownerElement;
    if (el && el != this._ownerElement) {
      throw new DOMException(INUSE_ATTRIBUTE_ERR);
    }
    var oldAttr = this.getNamedItem(attr.nodeName);
    _addNamedNode(this._ownerElement, this, attr, oldAttr);
    return oldAttr;
  },
  setNamedItemNS: function(attr) {
    var el = attr.ownerElement, oldAttr;
    if (el && el != this._ownerElement) {
      throw new DOMException(INUSE_ATTRIBUTE_ERR);
    }
    oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
    _addNamedNode(this._ownerElement, this, attr, oldAttr);
    return oldAttr;
  },
  removeNamedItem: function(key) {
    var attr = this.getNamedItem(key);
    _removeNamedNode(this._ownerElement, this, attr);
    return attr;
  },
  removeNamedItemNS: function(namespaceURI, localName) {
    var attr = this.getNamedItemNS(namespaceURI, localName);
    _removeNamedNode(this._ownerElement, this, attr);
    return attr;
  },
  getNamedItemNS: function(namespaceURI, localName) {
    var i = this.length;
    while (i--) {
      var node = this[i];
      if (node.localName == localName && node.namespaceURI == namespaceURI) {
        return node;
      }
    }
    return null;
  }
};
function DOMImplementation$1() {
}
DOMImplementation$1.prototype = {
  hasFeature: function(feature, version) {
    return true;
  },
  createDocument: function(namespaceURI, qualifiedName, doctype) {
    var doc = new Document();
    doc.implementation = this;
    doc.childNodes = new NodeList();
    doc.doctype = doctype || null;
    if (doctype) {
      doc.appendChild(doctype);
    }
    if (qualifiedName) {
      var root = doc.createElementNS(namespaceURI, qualifiedName);
      doc.appendChild(root);
    }
    return doc;
  },
  createDocumentType: function(qualifiedName, publicId, systemId) {
    var node = new DocumentType();
    node.name = qualifiedName;
    node.nodeName = qualifiedName;
    node.publicId = publicId || "";
    node.systemId = systemId || "";
    return node;
  }
};
function Node() {
}
Node.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  insertBefore: function(newChild, refChild) {
    return _insertBefore(this, newChild, refChild);
  },
  replaceChild: function(newChild, oldChild) {
    this.insertBefore(newChild, oldChild);
    if (oldChild) {
      this.removeChild(oldChild);
    }
  },
  removeChild: function(oldChild) {
    return _removeChild(this, oldChild);
  },
  appendChild: function(newChild) {
    return this.insertBefore(newChild, null);
  },
  hasChildNodes: function() {
    return this.firstChild != null;
  },
  cloneNode: function(deep) {
    return cloneNode(this.ownerDocument || this, this, deep);
  },
  normalize: function() {
    var child = this.firstChild;
    while (child) {
      var next = child.nextSibling;
      if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
        this.removeChild(next);
        child.appendData(next.data);
      } else {
        child.normalize();
        child = next;
      }
    }
  },
  isSupported: function(feature, version) {
    return this.ownerDocument.implementation.hasFeature(feature, version);
  },
  hasAttributes: function() {
    return this.attributes.length > 0;
  },
  lookupPrefix: function(namespaceURI) {
    var el = this;
    while (el) {
      var map = el._nsMap;
      if (map) {
        for (var n in map) {
          if (map[n] == namespaceURI) {
            return n;
          }
        }
      }
      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
    }
    return null;
  },
  lookupNamespaceURI: function(prefix) {
    var el = this;
    while (el) {
      var map = el._nsMap;
      if (map) {
        if (prefix in map) {
          return map[prefix];
        }
      }
      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
    }
    return null;
  },
  isDefaultNamespace: function(namespaceURI) {
    var prefix = this.lookupPrefix(namespaceURI);
    return prefix == null;
  }
};
function _xmlEncoder(c) {
  return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
}
copy(NodeType, Node);
copy(NodeType, Node.prototype);
function _visitNode(node, callback) {
  if (callback(node)) {
    return true;
  }
  if (node = node.firstChild) {
    do {
      if (_visitNode(node, callback)) {
        return true;
      }
    } while (node = node.nextSibling);
  }
}
function Document() {
}
function _onAddAttribute(doc, el, newAttr) {
  doc && doc._inc++;
  var ns = newAttr.namespaceURI;
  if (ns === NAMESPACE$1.XMLNS) {
    el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
  }
}
function _onRemoveAttribute(doc, el, newAttr, remove) {
  doc && doc._inc++;
  var ns = newAttr.namespaceURI;
  if (ns === NAMESPACE$1.XMLNS) {
    delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
  }
}
function _onUpdateChild(doc, el, newChild) {
  if (doc && doc._inc) {
    doc._inc++;
    var cs = el.childNodes;
    if (newChild) {
      cs[cs.length++] = newChild;
    } else {
      var child = el.firstChild;
      var i = 0;
      while (child) {
        cs[i++] = child;
        child = child.nextSibling;
      }
      cs.length = i;
    }
  }
}
function _removeChild(parentNode, child) {
  var previous = child.previousSibling;
  var next = child.nextSibling;
  if (previous) {
    previous.nextSibling = next;
  } else {
    parentNode.firstChild = next;
  }
  if (next) {
    next.previousSibling = previous;
  } else {
    parentNode.lastChild = previous;
  }
  _onUpdateChild(parentNode.ownerDocument, parentNode);
  return child;
}
function _insertBefore(parentNode, newChild, nextChild) {
  var cp = newChild.parentNode;
  if (cp) {
    cp.removeChild(newChild);
  }
  if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
    var newFirst = newChild.firstChild;
    if (newFirst == null) {
      return newChild;
    }
    var newLast = newChild.lastChild;
  } else {
    newFirst = newLast = newChild;
  }
  var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;
  newFirst.previousSibling = pre;
  newLast.nextSibling = nextChild;
  if (pre) {
    pre.nextSibling = newFirst;
  } else {
    parentNode.firstChild = newFirst;
  }
  if (nextChild == null) {
    parentNode.lastChild = newLast;
  } else {
    nextChild.previousSibling = newLast;
  }
  do {
    newFirst.parentNode = parentNode;
  } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
  _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);
  if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
    newChild.firstChild = newChild.lastChild = null;
  }
  return newChild;
}
function _appendSingleChild(parentNode, newChild) {
  var cp = newChild.parentNode;
  if (cp) {
    var pre = parentNode.lastChild;
    cp.removeChild(newChild);
    var pre = parentNode.lastChild;
  }
  var pre = parentNode.lastChild;
  newChild.parentNode = parentNode;
  newChild.previousSibling = pre;
  newChild.nextSibling = null;
  if (pre) {
    pre.nextSibling = newChild;
  } else {
    parentNode.firstChild = newChild;
  }
  parentNode.lastChild = newChild;
  _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
  return newChild;
}
Document.prototype = {
  nodeName: "#document",
  nodeType: DOCUMENT_NODE,
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function(newChild, refChild) {
    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
      var child = newChild.firstChild;
      while (child) {
        var next = child.nextSibling;
        this.insertBefore(child, refChild);
        child = next;
      }
      return newChild;
    }
    if (this.documentElement == null && newChild.nodeType == ELEMENT_NODE) {
      this.documentElement = newChild;
    }
    return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild;
  },
  removeChild: function(oldChild) {
    if (this.documentElement == oldChild) {
      this.documentElement = null;
    }
    return _removeChild(this, oldChild);
  },
  importNode: function(importedNode, deep) {
    return importNode(this, importedNode, deep);
  },
  getElementById: function(id) {
    var rtv = null;
    _visitNode(this.documentElement, function(node) {
      if (node.nodeType == ELEMENT_NODE) {
        if (node.getAttribute("id") == id) {
          rtv = node;
          return true;
        }
      }
    });
    return rtv;
  },
  getElementsByClassName: function(classNames) {
    var classNamesSet = toOrderedSet(classNames);
    return new LiveNodeList(this, function(base) {
      var ls = [];
      if (classNamesSet.length > 0) {
        _visitNode(base.documentElement, function(node) {
          if (node !== base && node.nodeType === ELEMENT_NODE) {
            var nodeClassNames = node.getAttribute("class");
            if (nodeClassNames) {
              var matches = classNames === nodeClassNames;
              if (!matches) {
                var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
              }
              if (matches) {
                ls.push(node);
              }
            }
          }
        });
      }
      return ls;
    });
  },
  createElement: function(tagName) {
    var node = new Element();
    node.ownerDocument = this;
    node.nodeName = tagName;
    node.tagName = tagName;
    node.localName = tagName;
    node.childNodes = new NodeList();
    var attrs = node.attributes = new NamedNodeMap();
    attrs._ownerElement = node;
    return node;
  },
  createDocumentFragment: function() {
    var node = new DocumentFragment();
    node.ownerDocument = this;
    node.childNodes = new NodeList();
    return node;
  },
  createTextNode: function(data2) {
    var node = new Text();
    node.ownerDocument = this;
    node.appendData(data2);
    return node;
  },
  createComment: function(data2) {
    var node = new Comment();
    node.ownerDocument = this;
    node.appendData(data2);
    return node;
  },
  createCDATASection: function(data2) {
    var node = new CDATASection();
    node.ownerDocument = this;
    node.appendData(data2);
    return node;
  },
  createProcessingInstruction: function(target, data2) {
    var node = new ProcessingInstruction();
    node.ownerDocument = this;
    node.tagName = node.target = target;
    node.nodeValue = node.data = data2;
    return node;
  },
  createAttribute: function(name) {
    var node = new Attr();
    node.ownerDocument = this;
    node.name = name;
    node.nodeName = name;
    node.localName = name;
    node.specified = true;
    return node;
  },
  createEntityReference: function(name) {
    var node = new EntityReference();
    node.ownerDocument = this;
    node.nodeName = name;
    return node;
  },
  createElementNS: function(namespaceURI, qualifiedName) {
    var node = new Element();
    var pl = qualifiedName.split(":");
    var attrs = node.attributes = new NamedNodeMap();
    node.childNodes = new NodeList();
    node.ownerDocument = this;
    node.nodeName = qualifiedName;
    node.tagName = qualifiedName;
    node.namespaceURI = namespaceURI;
    if (pl.length == 2) {
      node.prefix = pl[0];
      node.localName = pl[1];
    } else {
      node.localName = qualifiedName;
    }
    attrs._ownerElement = node;
    return node;
  },
  createAttributeNS: function(namespaceURI, qualifiedName) {
    var node = new Attr();
    var pl = qualifiedName.split(":");
    node.ownerDocument = this;
    node.nodeName = qualifiedName;
    node.name = qualifiedName;
    node.namespaceURI = namespaceURI;
    node.specified = true;
    if (pl.length == 2) {
      node.prefix = pl[0];
      node.localName = pl[1];
    } else {
      node.localName = qualifiedName;
    }
    return node;
  }
};
_extends(Document, Node);
function Element() {
  this._nsMap = {};
}
Element.prototype = {
  nodeType: ELEMENT_NODE,
  hasAttribute: function(name) {
    return this.getAttributeNode(name) != null;
  },
  getAttribute: function(name) {
    var attr = this.getAttributeNode(name);
    return attr && attr.value || "";
  },
  getAttributeNode: function(name) {
    return this.attributes.getNamedItem(name);
  },
  setAttribute: function(name, value) {
    var attr = this.ownerDocument.createAttribute(name);
    attr.value = attr.nodeValue = "" + value;
    this.setAttributeNode(attr);
  },
  removeAttribute: function(name) {
    var attr = this.getAttributeNode(name);
    attr && this.removeAttributeNode(attr);
  },
  appendChild: function(newChild) {
    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return this.insertBefore(newChild, null);
    } else {
      return _appendSingleChild(this, newChild);
    }
  },
  setAttributeNode: function(newAttr) {
    return this.attributes.setNamedItem(newAttr);
  },
  setAttributeNodeNS: function(newAttr) {
    return this.attributes.setNamedItemNS(newAttr);
  },
  removeAttributeNode: function(oldAttr) {
    return this.attributes.removeNamedItem(oldAttr.nodeName);
  },
  removeAttributeNS: function(namespaceURI, localName) {
    var old = this.getAttributeNodeNS(namespaceURI, localName);
    old && this.removeAttributeNode(old);
  },
  hasAttributeNS: function(namespaceURI, localName) {
    return this.getAttributeNodeNS(namespaceURI, localName) != null;
  },
  getAttributeNS: function(namespaceURI, localName) {
    var attr = this.getAttributeNodeNS(namespaceURI, localName);
    return attr && attr.value || "";
  },
  setAttributeNS: function(namespaceURI, qualifiedName, value) {
    var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
    attr.value = attr.nodeValue = "" + value;
    this.setAttributeNode(attr);
  },
  getAttributeNodeNS: function(namespaceURI, localName) {
    return this.attributes.getNamedItemNS(namespaceURI, localName);
  },
  getElementsByTagName: function(tagName) {
    return new LiveNodeList(this, function(base) {
      var ls = [];
      _visitNode(base, function(node) {
        if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
          ls.push(node);
        }
      });
      return ls;
    });
  },
  getElementsByTagNameNS: function(namespaceURI, localName) {
    return new LiveNodeList(this, function(base) {
      var ls = [];
      _visitNode(base, function(node) {
        if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
          ls.push(node);
        }
      });
      return ls;
    });
  }
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
_extends(Element, Node);
function Attr() {
}
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr, Node);
function CharacterData() {
}
CharacterData.prototype = {
  data: "",
  substringData: function(offset, count) {
    return this.data.substring(offset, offset + count);
  },
  appendData: function(text2) {
    text2 = this.data + text2;
    this.nodeValue = this.data = text2;
    this.length = text2.length;
  },
  insertData: function(offset, text2) {
    this.replaceData(offset, 0, text2);
  },
  appendChild: function(newChild) {
    throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
  },
  deleteData: function(offset, count) {
    this.replaceData(offset, count, "");
  },
  replaceData: function(offset, count, text2) {
    var start = this.data.substring(0, offset);
    var end = this.data.substring(offset + count);
    text2 = start + text2 + end;
    this.nodeValue = this.data = text2;
    this.length = text2.length;
  }
};
_extends(CharacterData, Node);
function Text() {
}
Text.prototype = {
  nodeName: "#text",
  nodeType: TEXT_NODE,
  splitText: function(offset) {
    var text2 = this.data;
    var newText = text2.substring(offset);
    text2 = text2.substring(0, offset);
    this.data = this.nodeValue = text2;
    this.length = text2.length;
    var newNode = this.ownerDocument.createTextNode(newText);
    if (this.parentNode) {
      this.parentNode.insertBefore(newNode, this.nextSibling);
    }
    return newNode;
  }
};
_extends(Text, CharacterData);
function Comment() {
}
Comment.prototype = {
  nodeName: "#comment",
  nodeType: COMMENT_NODE
};
_extends(Comment, CharacterData);
function CDATASection() {
}
CDATASection.prototype = {
  nodeName: "#cdata-section",
  nodeType: CDATA_SECTION_NODE
};
_extends(CDATASection, CharacterData);
function DocumentType() {
}
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType, Node);
function Notation() {
}
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation, Node);
function Entity() {
}
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity, Node);
function EntityReference() {
}
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference, Node);
function DocumentFragment() {
}
DocumentFragment.prototype.nodeName = "#document-fragment";
DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment, Node);
function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction, Node);
function XMLSerializer() {
}
XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
  return nodeSerializeToString.call(node, isHtml, nodeFilter);
};
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml, nodeFilter) {
  var buf = [];
  var refNode = this.nodeType == 9 && this.documentElement || this;
  var prefix = refNode.prefix;
  var uri = refNode.namespaceURI;
  if (uri && prefix == null) {
    var prefix = refNode.lookupPrefix(uri);
    if (prefix == null) {
      var visibleNamespaces = [
        { namespace: uri, prefix: null }
      ];
    }
  }
  serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
  return buf.join("");
}
function needNamespaceDefine(node, isHTML, visibleNamespaces) {
  var prefix = node.prefix || "";
  var uri = node.namespaceURI;
  if (!uri) {
    return false;
  }
  if (prefix === "xml" && uri === NAMESPACE$1.XML || uri === NAMESPACE$1.XMLNS) {
    return false;
  }
  var i = visibleNamespaces.length;
  while (i--) {
    var ns = visibleNamespaces[i];
    if (ns.prefix === prefix) {
      return ns.namespace !== uri;
    }
  }
  return true;
}
function addSerializedAttribute(buf, qualifiedName, value) {
  buf.push(" ", qualifiedName, '="', value.replace(/[<&"]/g, _xmlEncoder), '"');
}
function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
  if (!visibleNamespaces) {
    visibleNamespaces = [];
  }
  if (nodeFilter) {
    node = nodeFilter(node);
    if (node) {
      if (typeof node == "string") {
        buf.push(node);
        return;
      }
    } else {
      return;
    }
  }
  switch (node.nodeType) {
    case ELEMENT_NODE:
      var attrs = node.attributes;
      var len = attrs.length;
      var child = node.firstChild;
      var nodeName = node.tagName;
      isHTML = NAMESPACE$1.isHTML(node.namespaceURI) || isHTML;
      var prefixedNodeName = nodeName;
      if (!isHTML && !node.prefix && node.namespaceURI) {
        var defaultNS;
        for (var ai = 0; ai < attrs.length; ai++) {
          if (attrs.item(ai).name === "xmlns") {
            defaultNS = attrs.item(ai).value;
            break;
          }
        }
        if (defaultNS !== node.namespaceURI) {
          for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
            var namespace = visibleNamespaces[nsi];
            if (namespace.namespace === node.namespaceURI) {
              if (namespace.prefix) {
                prefixedNodeName = namespace.prefix + ":" + nodeName;
              }
              break;
            }
          }
        }
      }
      buf.push("<", prefixedNodeName);
      for (var i = 0; i < len; i++) {
        var attr = attrs.item(i);
        if (attr.prefix == "xmlns") {
          visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
        } else if (attr.nodeName == "xmlns") {
          visibleNamespaces.push({ prefix: "", namespace: attr.value });
        }
      }
      for (var i = 0; i < len; i++) {
        var attr = attrs.item(i);
        if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
          var prefix = attr.prefix || "";
          var uri = attr.namespaceURI;
          addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
          visibleNamespaces.push({ prefix, namespace: uri });
        }
        serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
      }
      if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
        var prefix = node.prefix || "";
        var uri = node.namespaceURI;
        addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
        visibleNamespaces.push({ prefix, namespace: uri });
      }
      if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
        buf.push(">");
        if (isHTML && /^script$/i.test(nodeName)) {
          while (child) {
            if (child.data) {
              buf.push(child.data);
            } else {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            }
            child = child.nextSibling;
          }
        } else {
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
        }
        buf.push("</", prefixedNodeName, ">");
      } else {
        buf.push("/>");
      }
      return;
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      var child = node.firstChild;
      while (child) {
        serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
        child = child.nextSibling;
      }
      return;
    case ATTRIBUTE_NODE:
      return addSerializedAttribute(buf, node.name, node.value);
    case TEXT_NODE:
      return buf.push(
        node.data.replace(/[<&]/g, _xmlEncoder).replace(/]]>/g, "]]&gt;")
      );
    case CDATA_SECTION_NODE:
      return buf.push("<![CDATA[", node.data, "]]>");
    case COMMENT_NODE:
      return buf.push("<!--", node.data, "-->");
    case DOCUMENT_TYPE_NODE:
      var pubid = node.publicId;
      var sysid = node.systemId;
      buf.push("<!DOCTYPE ", node.name);
      if (pubid) {
        buf.push(" PUBLIC ", pubid);
        if (sysid && sysid != ".") {
          buf.push(" ", sysid);
        }
        buf.push(">");
      } else if (sysid && sysid != ".") {
        buf.push(" SYSTEM ", sysid, ">");
      } else {
        var sub = node.internalSubset;
        if (sub) {
          buf.push(" [", sub, "]");
        }
        buf.push(">");
      }
      return;
    case PROCESSING_INSTRUCTION_NODE:
      return buf.push("<?", node.target, " ", node.data, "?>");
    case ENTITY_REFERENCE_NODE:
      return buf.push("&", node.nodeName, ";");
    default:
      buf.push("??", node.nodeName);
  }
}
function importNode(doc, node, deep) {
  var node2;
  switch (node.nodeType) {
    case ELEMENT_NODE:
      node2 = node.cloneNode(false);
      node2.ownerDocument = doc;
    case DOCUMENT_FRAGMENT_NODE:
      break;
    case ATTRIBUTE_NODE:
      deep = true;
      break;
  }
  if (!node2) {
    node2 = node.cloneNode(false);
  }
  node2.ownerDocument = doc;
  node2.parentNode = null;
  if (deep) {
    var child = node.firstChild;
    while (child) {
      node2.appendChild(importNode(doc, child, deep));
      child = child.nextSibling;
    }
  }
  return node2;
}
function cloneNode(doc, node, deep) {
  var node2 = new node.constructor();
  for (var n in node) {
    var v = node[n];
    if (typeof v != "object") {
      if (v != node2[n]) {
        node2[n] = v;
      }
    }
  }
  if (node.childNodes) {
    node2.childNodes = new NodeList();
  }
  node2.ownerDocument = doc;
  switch (node2.nodeType) {
    case ELEMENT_NODE:
      var attrs = node.attributes;
      var attrs2 = node2.attributes = new NamedNodeMap();
      var len = attrs.length;
      attrs2._ownerElement = node2;
      for (var i = 0; i < len; i++) {
        node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
      }
      break;
    case ATTRIBUTE_NODE:
      deep = true;
  }
  if (deep) {
    var child = node.firstChild;
    while (child) {
      node2.appendChild(cloneNode(doc, child, deep));
      child = child.nextSibling;
    }
  }
  return node2;
}
function __set__(object, key, value) {
  object[key] = value;
}
try {
  if (Object.defineProperty) {
    let getTextContent = function(node) {
      switch (node.nodeType) {
        case ELEMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var buf = [];
          node = node.firstChild;
          while (node) {
            if (node.nodeType !== 7 && node.nodeType !== 8) {
              buf.push(getTextContent(node));
            }
            node = node.nextSibling;
          }
          return buf.join("");
        default:
          return node.nodeValue;
      }
    };
    Object.defineProperty(LiveNodeList.prototype, "length", {
      get: function() {
        _updateLiveList(this);
        return this.$$length;
      }
    });
    Object.defineProperty(Node.prototype, "textContent", {
      get: function() {
        return getTextContent(this);
      },
      set: function(data2) {
        switch (this.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            while (this.firstChild) {
              this.removeChild(this.firstChild);
            }
            if (data2 || String(data2)) {
              this.appendChild(this.ownerDocument.createTextNode(data2));
            }
            break;
          default:
            this.data = data2;
            this.value = data2;
            this.nodeValue = data2;
        }
      }
    });
    __set__ = function(object, key, value) {
      object["$$" + key] = value;
    };
  }
} catch (e) {
}
dom.DocumentType = DocumentType;
dom.DOMException = DOMException;
dom.DOMImplementation = DOMImplementation$1;
dom.Element = Element;
dom.Node = Node;
dom.NodeList = NodeList;
dom.XMLSerializer = XMLSerializer;
var conventions = conventions$2;
var entities = entities$1;
var NAMESPACE = conventions.NAMESPACE;
function DOMParser(options) {
  this.options = options || { locator: {} };
}
DOMParser.prototype.parseFromString = function(source, mimeType) {
  var options = this.options;
  var sax2 = new XMLReader();
  var domBuilder = options.domBuilder || new DOMHandler();
  var errorHandler = options.errorHandler;
  var locator = options.locator;
  var defaultNSMap = options.xmlns || {};
  var isHTML = /\/x?html?$/.test(mimeType);
  var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
  if (locator) {
    domBuilder.setDocumentLocator(locator);
  }
  sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
  sax2.domBuilder = options.domBuilder || domBuilder;
  if (isHTML) {
    defaultNSMap[""] = NAMESPACE.HTML;
  }
  defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
  if (source && typeof source === "string") {
    sax2.parse(source, defaultNSMap, entityMap);
  } else {
    sax2.errorHandler.error("invalid doc source");
  }
  return domBuilder.doc;
};
function buildErrorHandler(errorImpl, domBuilder, locator) {
  if (!errorImpl) {
    if (domBuilder instanceof DOMHandler) {
      return domBuilder;
    }
    errorImpl = domBuilder;
  }
  var errorHandler = {};
  var isCallback = errorImpl instanceof Function;
  locator = locator || {};
  function build(key) {
    var fn = errorImpl[key];
    if (!fn && isCallback) {
      fn = errorImpl.length == 2 ? function(msg) {
        errorImpl(key, msg);
      } : errorImpl;
    }
    errorHandler[key] = fn && function(msg) {
      fn("[xmldom " + key + "]	" + msg + _locator(locator));
    } || function() {
    };
  }
  build("warning");
  build("error");
  build("fatalError");
  return errorHandler;
}
function DOMHandler() {
  this.cdata = false;
}
function position(locator, node) {
  node.lineNumber = locator.lineNumber;
  node.columnNumber = locator.columnNumber;
}
DOMHandler.prototype = {
  startDocument: function() {
    this.doc = new DOMImplementation().createDocument(null, null, null);
    if (this.locator) {
      this.doc.documentURI = this.locator.systemId;
    }
  },
  startElement: function(namespaceURI, localName, qName, attrs) {
    var doc = this.doc;
    var el = doc.createElementNS(namespaceURI, qName || localName);
    var len = attrs.length;
    appendElement(this, el);
    this.currentElement = el;
    this.locator && position(this.locator, el);
    for (var i = 0; i < len; i++) {
      var namespaceURI = attrs.getURI(i);
      var value = attrs.getValue(i);
      var qName = attrs.getQName(i);
      var attr = doc.createAttributeNS(namespaceURI, qName);
      this.locator && position(attrs.getLocator(i), attr);
      attr.value = attr.nodeValue = value;
      el.setAttributeNode(attr);
    }
  },
  endElement: function(namespaceURI, localName, qName) {
    var current = this.currentElement;
    current.tagName;
    this.currentElement = current.parentNode;
  },
  startPrefixMapping: function(prefix, uri) {
  },
  endPrefixMapping: function(prefix) {
  },
  processingInstruction: function(target, data2) {
    var ins = this.doc.createProcessingInstruction(target, data2);
    this.locator && position(this.locator, ins);
    appendElement(this, ins);
  },
  ignorableWhitespace: function(ch, start, length) {
  },
  characters: function(chars, start, length) {
    chars = _toString.apply(this, arguments);
    if (chars) {
      if (this.cdata) {
        var charNode = this.doc.createCDATASection(chars);
      } else {
        var charNode = this.doc.createTextNode(chars);
      }
      if (this.currentElement) {
        this.currentElement.appendChild(charNode);
      } else if (/^\s*$/.test(chars)) {
        this.doc.appendChild(charNode);
      }
      this.locator && position(this.locator, charNode);
    }
  },
  skippedEntity: function(name) {
  },
  endDocument: function() {
    this.doc.normalize();
  },
  setDocumentLocator: function(locator) {
    if (this.locator = locator) {
      locator.lineNumber = 0;
    }
  },
  comment: function(chars, start, length) {
    chars = _toString.apply(this, arguments);
    var comm = this.doc.createComment(chars);
    this.locator && position(this.locator, comm);
    appendElement(this, comm);
  },
  startCDATA: function() {
    this.cdata = true;
  },
  endCDATA: function() {
    this.cdata = false;
  },
  startDTD: function(name, publicId, systemId) {
    var impl = this.doc.implementation;
    if (impl && impl.createDocumentType) {
      var dt = impl.createDocumentType(name, publicId, systemId);
      this.locator && position(this.locator, dt);
      appendElement(this, dt);
    }
  },
  warning: function(error2) {
    console.warn("[xmldom warning]	" + error2, _locator(this.locator));
  },
  error: function(error2) {
    console.error("[xmldom error]	" + error2, _locator(this.locator));
  },
  fatalError: function(error2) {
    throw new ParseError(error2, this.locator);
  }
};
function _locator(l) {
  if (l) {
    return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
  }
}
function _toString(chars, start, length) {
  if (typeof chars == "string") {
    return chars.substr(start, length);
  } else {
    if (chars.length >= start + length || start) {
      return new java.lang.String(chars, start, length) + "";
    }
    return chars;
  }
}
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
  DOMHandler.prototype[key] = function() {
    return null;
  };
});
function appendElement(hander, node) {
  if (!hander.currentElement) {
    hander.doc.appendChild(node);
  } else {
    hander.currentElement.appendChild(node);
  }
}
var sax = sax$1;
var XMLReader = sax.XMLReader;
var ParseError = sax.ParseError;
var DOMImplementation = domParser.DOMImplementation = dom.DOMImplementation;
domParser.XMLSerializer = dom.XMLSerializer;
domParser.DOMParser = DOMParser;
domParser.__DOMHandler = DOMHandler;
var parseJson$1 = {};
Object.defineProperty(parseJson$1, "__esModule", { value: true });
parseJson$1.parseJson = void 0;
function parseJson(data2) {
  try {
    var json2 = JSON.parse(data2);
    return json2;
  } catch (_) {
    return null;
  }
}
parseJson$1.parseJson = parseJson;
var bufferFrom$1 = {};
Object.defineProperty(bufferFrom$1, "__esModule", { value: true });
bufferFrom$1.bufferFrom = void 0;
function bufferFrom(init) {
  var encodedString = encodeURIComponent(init);
  var binaryString = encodedString.replace(/%([0-9A-F]{2})/g, function(_, char) {
    return String.fromCharCode("0x" + char);
  });
  var buffer = new Uint8Array(binaryString.length);
  Array.prototype.forEach.call(binaryString, function(char, index2) {
    buffer[index2] = char.charCodeAt(0);
  });
  return buffer;
}
bufferFrom$1.bufferFrom = bufferFrom;
var createEvent$1 = {};
var EventPolyfill$1 = {};
Object.defineProperty(EventPolyfill$1, "__esModule", { value: true });
EventPolyfill$1.EventPolyfill = void 0;
var EventPolyfill = function() {
  function EventPolyfill2(type, options) {
    this.AT_TARGET = 0;
    this.BUBBLING_PHASE = 0;
    this.CAPTURING_PHASE = 0;
    this.NONE = 0;
    this.type = "";
    this.srcElement = null;
    this.currentTarget = null;
    this.eventPhase = 0;
    this.isTrusted = true;
    this.composed = false;
    this.cancelable = true;
    this.defaultPrevented = false;
    this.bubbles = true;
    this.lengthComputable = true;
    this.loaded = 0;
    this.total = 0;
    this.cancelBubble = false;
    this.returnValue = true;
    this.type = type;
    this.target = (options === null || options === void 0 ? void 0 : options.target) || null;
    this.currentTarget = (options === null || options === void 0 ? void 0 : options.currentTarget) || null;
    this.timeStamp = Date.now();
  }
  EventPolyfill2.prototype.composedPath = function() {
    return [];
  };
  EventPolyfill2.prototype.initEvent = function(type, bubbles, cancelable) {
    this.type = type;
    this.bubbles = !!bubbles;
    this.cancelable = !!cancelable;
  };
  EventPolyfill2.prototype.preventDefault = function() {
    this.defaultPrevented = true;
  };
  EventPolyfill2.prototype.stopPropagation = function() {
  };
  EventPolyfill2.prototype.stopImmediatePropagation = function() {
  };
  return EventPolyfill2;
}();
EventPolyfill$1.EventPolyfill = EventPolyfill;
var ProgressEventPolyfill$1 = {};
var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(ProgressEventPolyfill$1, "__esModule", { value: true });
ProgressEventPolyfill$1.ProgressEventPolyfill = void 0;
var EventPolyfill_1$1 = EventPolyfill$1;
var ProgressEventPolyfill = function(_super) {
  __extends2(ProgressEventPolyfill2, _super);
  function ProgressEventPolyfill2(type, init) {
    var _this = _super.call(this, type) || this;
    _this.lengthComputable = (init === null || init === void 0 ? void 0 : init.lengthComputable) || false;
    _this.composed = (init === null || init === void 0 ? void 0 : init.composed) || false;
    _this.loaded = (init === null || init === void 0 ? void 0 : init.loaded) || 0;
    _this.total = (init === null || init === void 0 ? void 0 : init.total) || 0;
    return _this;
  }
  return ProgressEventPolyfill2;
}(EventPolyfill_1$1.EventPolyfill);
ProgressEventPolyfill$1.ProgressEventPolyfill = ProgressEventPolyfill;
Object.defineProperty(createEvent$1, "__esModule", { value: true });
createEvent$1.createEvent = void 0;
var EventPolyfill_1 = EventPolyfill$1;
var ProgressEventPolyfill_1 = ProgressEventPolyfill$1;
var SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== "undefined";
function createEvent(target, type, init) {
  var progressEvents = [
    "error",
    "progress",
    "loadstart",
    "loadend",
    "load",
    "timeout",
    "abort"
  ];
  var ProgressEventClass = SUPPORTS_PROGRESS_EVENT ? ProgressEvent : ProgressEventPolyfill_1.ProgressEventPolyfill;
  var event = progressEvents.includes(type) ? new ProgressEventClass(type, {
    lengthComputable: true,
    loaded: (init === null || init === void 0 ? void 0 : init.loaded) || 0,
    total: (init === null || init === void 0 ? void 0 : init.total) || 0
  }) : new EventPolyfill_1.EventPolyfill(type, {
    target,
    currentTarget: target
  });
  return event;
}
createEvent$1.createEvent = createEvent;
var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body2) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body2.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __values2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
Object.defineProperty(XMLHttpRequestOverride, "__esModule", { value: true });
XMLHttpRequestOverride.createXMLHttpRequestOverride = void 0;
var until_1 = lib$2;
var headers_utils_1 = lib$1;
var xmldom_1 = domParser;
var parseJson_1 = parseJson$1;
var toIsoResponse_1 = toIsoResponse$1;
var uuid_1 = uuid;
var bufferFrom_1 = bufferFrom$1;
var createEvent_1 = createEvent$1;
var createDebug = import_debug.default;
var createXMLHttpRequestOverride = function(options) {
  var _a;
  var pureXMLHttpRequest2 = options.pureXMLHttpRequest, observer = options.observer, resolver = options.resolver;
  var debug2 = createDebug("XHR");
  return _a = function() {
    function XMLHttpRequestOverride2() {
      this._events = [];
      this.UNSENT = 0;
      this.OPENED = 1;
      this.HEADERS_RECEIVED = 2;
      this.LOADING = 3;
      this.DONE = 4;
      this.onreadystatechange = null;
      this.onabort = null;
      this.onerror = null;
      this.onload = null;
      this.onloadend = null;
      this.onloadstart = null;
      this.onprogress = null;
      this.ontimeout = null;
      this.url = "";
      this.method = "GET";
      this.readyState = this.UNSENT;
      this.withCredentials = false;
      this.status = 200;
      this.statusText = "OK";
      this.data = "";
      this.response = "";
      this.responseType = "text";
      this.responseText = "";
      this.responseXML = null;
      this.responseURL = "";
      this.upload = null;
      this.timeout = 0;
      this._requestHeaders = new headers_utils_1.Headers();
      this._responseHeaders = new headers_utils_1.Headers();
    }
    XMLHttpRequestOverride2.prototype.setReadyState = function(nextState) {
      if (nextState === this.readyState) {
        return;
      }
      debug2("readyState change %d -> %d", this.readyState, nextState);
      this.readyState = nextState;
      if (nextState !== this.UNSENT) {
        debug2("triggerring readystate change...");
        this.trigger("readystatechange");
      }
    };
    XMLHttpRequestOverride2.prototype.trigger = function(eventName, options2) {
      var e_1, _a2;
      debug2('trigger "%s" (%d)', eventName, this.readyState);
      debug2('resolve listener for event "%s"', eventName);
      var callback = this["on" + eventName];
      callback === null || callback === void 0 ? void 0 : callback.call(this, createEvent_1.createEvent(this, eventName, options2));
      try {
        for (var _b = __values2(this._events), _c = _b.next(); !_c.done; _c = _b.next()) {
          var event_1 = _c.value;
          if (event_1.name === eventName) {
            debug2('calling mock event listener "%s" (%d)', eventName, this.readyState);
            event_1.listener.call(this, createEvent_1.createEvent(this, eventName, options2));
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return this;
    };
    XMLHttpRequestOverride2.prototype.reset = function() {
      debug2("reset");
      this.setReadyState(this.UNSENT);
      this.status = 200;
      this.statusText = "OK";
      this.data = "";
      this.response = null;
      this.responseText = null;
      this.responseXML = null;
      this._requestHeaders = new headers_utils_1.Headers();
      this._responseHeaders = new headers_utils_1.Headers();
    };
    XMLHttpRequestOverride2.prototype.open = function(method, url, async, user, password) {
      if (async === void 0) {
        async = true;
      }
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a2) {
          debug2 = createDebug("XHR " + method + " " + url);
          debug2("open", { method, url, async, user, password });
          this.reset();
          this.setReadyState(this.OPENED);
          if (typeof url === "undefined") {
            this.url = method;
            this.method = "GET";
          } else {
            this.url = url;
            this.method = method;
            this.async = async;
            this.user = user;
            this.password = password;
          }
          return [2];
        });
      });
    };
    XMLHttpRequestOverride2.prototype.send = function(data2) {
      var _this = this;
      debug2("send %s %s", this.method, this.url);
      this.data = data2 || "";
      var url;
      try {
        url = new URL(this.url);
      } catch (error2) {
        url = new URL(this.url, window.location.href);
      }
      debug2("request headers", this._requestHeaders);
      var isoRequest = {
        id: uuid_1.uuidv4(),
        url,
        method: this.method,
        body: this.data,
        headers: this._requestHeaders
      };
      observer.emit("request", isoRequest);
      debug2("awaiting mocked response...");
      Promise.resolve(until_1.until(function() {
        return __awaiter2(_this, void 0, void 0, function() {
          return __generator2(this, function(_a2) {
            return [2, resolver(isoRequest, this)];
          });
        });
      })).then(function(_a2) {
        var _b;
        var _c = __read2(_a2, 2), middlewareException = _c[0], mockedResponse = _c[1];
        if (middlewareException) {
          debug2("middleware function threw an exception!", middlewareException);
          _this.trigger("error");
          _this.abort();
          return;
        }
        if (mockedResponse) {
          debug2("received mocked response", mockedResponse);
          _this.trigger("loadstart");
          _this.status = mockedResponse.status || 200;
          _this.statusText = mockedResponse.statusText || "OK";
          _this._responseHeaders = mockedResponse.headers ? headers_utils_1.objectToHeaders(mockedResponse.headers) : new headers_utils_1.Headers();
          debug2("set response status", _this.status, _this.statusText);
          debug2("set response headers", _this._responseHeaders);
          _this.setReadyState(_this.HEADERS_RECEIVED);
          debug2("response type", _this.responseType);
          _this.response = _this.getResponseBody(mockedResponse.body);
          _this.responseText = mockedResponse.body || "";
          _this.responseXML = _this.getResponseXML();
          debug2("set response body", _this.response);
          if (mockedResponse.body && _this.response) {
            _this.setReadyState(_this.LOADING);
            var bodyBuffer = bufferFrom_1.bufferFrom(mockedResponse.body);
            _this.trigger("progress", {
              loaded: bodyBuffer.length,
              total: bodyBuffer.length
            });
          }
          _this.setReadyState(_this.DONE);
          _this.trigger("load");
          _this.trigger("loadend");
          observer.emit("response", isoRequest, toIsoResponse_1.toIsoResponse(mockedResponse));
        } else {
          debug2("no mocked response received!");
          var originalRequest_1 = new pureXMLHttpRequest2();
          debug2("opening an original request %s %s", _this.method, _this.url);
          originalRequest_1.open(_this.method, _this.url, (_b = _this.async) !== null && _b !== void 0 ? _b : true, _this.user, _this.password);
          originalRequest_1.addEventListener("load", function() {
            debug2('original "onload"');
            _this.status = originalRequest_1.status;
            _this.statusText = originalRequest_1.statusText;
            _this.responseURL = originalRequest_1.responseURL;
            _this.responseType = originalRequest_1.responseType;
            _this.response = originalRequest_1.response;
            _this.responseText = originalRequest_1.responseText;
            _this.responseXML = originalRequest_1.responseXML;
            debug2("set mock request readyState to DONE");
            _this.setReadyState(_this.DONE);
            debug2("received original response", _this.status, _this.statusText);
            debug2("original response body:", _this.response);
            var responseHeaders = originalRequest_1.getAllResponseHeaders();
            debug2("original response headers:\n", responseHeaders);
            _this._responseHeaders = headers_utils_1.stringToHeaders(responseHeaders);
            debug2("original response headers (normalized)", _this._responseHeaders);
            debug2("original response finished");
            observer.emit("response", isoRequest, {
              status: originalRequest_1.status,
              statusText: originalRequest_1.statusText,
              headers: _this._responseHeaders,
              body: originalRequest_1.response
            });
          });
          _this.propagateCallbacks(originalRequest_1);
          _this.propagateListeners(originalRequest_1);
          _this.propagateHeaders(originalRequest_1, _this._requestHeaders);
          if (_this.async) {
            originalRequest_1.timeout = _this.timeout;
          }
          debug2("send", _this.data);
          originalRequest_1.send(_this.data);
        }
      });
    };
    XMLHttpRequestOverride2.prototype.abort = function() {
      debug2("abort");
      if (this.readyState > this.UNSENT && this.readyState < this.DONE) {
        this.setReadyState(this.UNSENT);
        this.trigger("abort");
      }
    };
    XMLHttpRequestOverride2.prototype.dispatchEvent = function() {
      return false;
    };
    XMLHttpRequestOverride2.prototype.setRequestHeader = function(name, value) {
      debug2('set request header "%s" to "%s"', name, value);
      this._requestHeaders.append(name, value);
    };
    XMLHttpRequestOverride2.prototype.getResponseHeader = function(name) {
      debug2('get response header "%s"', name);
      if (this.readyState < this.HEADERS_RECEIVED) {
        debug2("cannot return a header: headers not received (state: %s)", this.readyState);
        return null;
      }
      var headerValue = this._responseHeaders.get(name);
      debug2('resolved response header "%s" to "%s"', name, headerValue, this._responseHeaders);
      return headerValue;
    };
    XMLHttpRequestOverride2.prototype.getAllResponseHeaders = function() {
      debug2("get all response headers");
      if (this.readyState < this.HEADERS_RECEIVED) {
        debug2("cannot return headers: headers not received (state: %s)", this.readyState);
        return "";
      }
      return headers_utils_1.headersToString(this._responseHeaders);
    };
    XMLHttpRequestOverride2.prototype.addEventListener = function(name, listener) {
      debug2("addEventListener", name, listener);
      this._events.push({
        name,
        listener
      });
    };
    XMLHttpRequestOverride2.prototype.removeEventListener = function(name, listener) {
      debug2("removeEventListener", name, listener);
      this._events = this._events.filter(function(storedEvent) {
        return storedEvent.name !== name && storedEvent.listener !== listener;
      });
    };
    XMLHttpRequestOverride2.prototype.overrideMimeType = function() {
    };
    XMLHttpRequestOverride2.prototype.getResponseBody = function(body2) {
      var textBody = body2 !== null && body2 !== void 0 ? body2 : "";
      debug2("coerced response body to", textBody);
      switch (this.responseType) {
        case "json": {
          debug2("resolving response body as JSON");
          return parseJson_1.parseJson(textBody);
        }
        case "blob": {
          var blobType = this.getResponseHeader("content-type") || "text/plain";
          debug2("resolving response body as Blob", { type: blobType });
          return new Blob([textBody], {
            type: blobType
          });
        }
        case "arraybuffer": {
          debug2("resolving response body as ArrayBuffer");
          var arrayBuffer = bufferFrom_1.bufferFrom(textBody);
          return arrayBuffer;
        }
        default:
          return textBody;
      }
    };
    XMLHttpRequestOverride2.prototype.getResponseXML = function() {
      var contentType = this.getResponseHeader("Content-Type");
      if (contentType === "application/xml" || contentType === "text/xml") {
        return new xmldom_1.DOMParser().parseFromString(this.responseText, contentType);
      }
      return null;
    };
    XMLHttpRequestOverride2.prototype.propagateCallbacks = function(request) {
      request.onabort = this.abort;
      request.onerror = this.onerror;
      request.ontimeout = this.ontimeout;
      request.onload = this.onload;
      request.onloadstart = this.onloadstart;
      request.onloadend = this.onloadend;
      request.onprogress = this.onprogress;
      request.onreadystatechange = this.onreadystatechange;
    };
    XMLHttpRequestOverride2.prototype.propagateListeners = function(request) {
      debug2("propagating request listeners (%d) to the original request", this._events.length, this._events);
      this._events.forEach(function(_a2) {
        var name = _a2.name, listener = _a2.listener;
        request.addEventListener(name, listener);
      });
    };
    XMLHttpRequestOverride2.prototype.propagateHeaders = function(request, headers) {
      debug2("propagating request headers to the original request", headers);
      Object.entries(headers.raw()).forEach(function(_a2) {
        var _b = __read2(_a2, 2), name = _b[0], value = _b[1];
        debug2('setting "%s" (%s) header on the original request', name, value);
        request.setRequestHeader(name, value);
      });
    };
    return XMLHttpRequestOverride2;
  }(), _a.UNSENT = 0, _a.OPENED = 1, _a.HEADERS_RECEIVED = 2, _a.LOADING = 3, _a.DONE = 4, _a;
};
XMLHttpRequestOverride.createXMLHttpRequestOverride = createXMLHttpRequestOverride;
Object.defineProperty(XMLHttpRequest, "__esModule", { value: true });
var interceptXMLHttpRequest_1 = XMLHttpRequest.interceptXMLHttpRequest = void 0;
var XMLHttpRequestOverride_1 = XMLHttpRequestOverride;
var debug = (0, import_debug.default)("XHR");
var pureXMLHttpRequest = typeof window === "undefined" ? void 0 : window.XMLHttpRequest;
var interceptXMLHttpRequest = function(observer, resolver) {
  if (pureXMLHttpRequest) {
    debug('patching "XMLHttpRequest" module...');
    var XMLHttpRequestOverride2 = XMLHttpRequestOverride_1.createXMLHttpRequestOverride({
      pureXMLHttpRequest,
      observer,
      resolver
    });
    window.XMLHttpRequest = XMLHttpRequestOverride2;
  }
  return function() {
    if (pureXMLHttpRequest) {
      debug("restoring modules...");
      window.XMLHttpRequest = pureXMLHttpRequest;
    }
  };
};
interceptXMLHttpRequest_1 = XMLHttpRequest.interceptXMLHttpRequest = interceptXMLHttpRequest;
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function parseIsomorphicRequest(request) {
  const requestId = uuidv4();
  request.headers.set("x-msw-request-id", requestId);
  const mockedRequest = {
    id: requestId,
    url: request.url,
    method: request.method,
    body: parseBody(request.body, request.headers),
    headers: request.headers,
    cookies: {},
    redirect: "manual",
    referrer: "",
    keepalive: false,
    cache: "default",
    mode: "cors",
    referrerPolicy: "no-referrer",
    integrity: "",
    destination: "document",
    bodyUsed: false,
    credentials: "same-origin"
  };
  const requestCookiesString = request.headers.get("cookie");
  setRequestCookies(mockedRequest);
  const requestCookies = requestCookiesString ? parse_1(requestCookiesString) : {};
  mockedRequest.cookies = Object.assign(Object.assign({}, mockedRequest.cookies), requestCookies);
  return mockedRequest;
}
function createFallbackRequestListener(context, options) {
  const interceptor = lib3.createInterceptor({
    modules: [interceptFetch_1, interceptXMLHttpRequest_1],
    resolver(request) {
      return __awaiter(this, void 0, void 0, function* () {
        const mockedRequest = parseIsomorphicRequest(request);
        return handleRequest(mockedRequest, context.requestHandlers, options, context.emitter, {
          transformResponse(response2) {
            return {
              status: response2.status,
              statusText: response2.statusText,
              headers: response2.headers.all(),
              body: response2.body
            };
          },
          onMockedResponseSent(response2, { handler, publicRequest, parsedRequest }) {
            if (!options.quiet) {
              handler.log(publicRequest, response2, handler, parsedRequest);
            }
          }
        });
      });
    }
  });
  interceptor.apply();
  return interceptor;
}
function createFallbackStart(context) {
  return function start(options) {
    return __awaiter(this, void 0, void 0, function* () {
      context.fallbackInterceptor = createFallbackRequestListener(context, options);
      printStartMessage({
        message: "Mocking enabled (fallback mode).",
        quiet: options.quiet
      });
      return void 0;
    });
  };
}
function createFallbackStop(context) {
  return function stop() {
    var _a, _b;
    (_a = context.fallbackInterceptor) === null || _a === void 0 ? void 0 : _a.restore();
    printStopMessage({ quiet: (_b = context.startOptions) === null || _b === void 0 ? void 0 : _b.quiet });
  };
}
function pipeEvents(source, destination) {
  const rawEmit = source.emit;
  if (rawEmit._isPiped) {
    return;
  }
  source.emit = function(event, ...data2) {
    destination.emit(event, ...data2);
    return rawEmit.call(this, event, ...data2);
  };
  source.emit._isPiped = true;
}
var listeners2 = [];
function setupWorker(...requestHandlers) {
  requestHandlers.forEach((handler) => {
    if (Array.isArray(handler))
      throw new Error(devUtils.formatMessage('Failed to call "setupWorker" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).'));
  });
  if (lib.exports.isNodeProcess()) {
    throw new Error(devUtils.formatMessage("Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead."));
  }
  const emitter = new lib$3.StrictEventEmitter();
  const publicEmitter = new lib$3.StrictEventEmitter();
  pipeEvents(emitter, publicEmitter);
  const context = {
    startOptions: void 0,
    worker: null,
    registration: null,
    requestHandlers: [...requestHandlers],
    emitter,
    workerChannel: {
      on(eventType, callback) {
        context.events.addListener(navigator.serviceWorker, "message", (event) => {
          if (event.source !== context.worker) {
            return;
          }
          const message = jsonParse(event.data);
          if (!message) {
            return;
          }
          if (message.type === eventType) {
            callback(event, message);
          }
        });
      },
      send(type) {
        var _a;
        (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage(type);
      }
    },
    events: {
      addListener(target, eventType, callback) {
        target.addEventListener(eventType, callback);
        listeners2.push({ eventType, target, callback });
        return () => {
          target.removeEventListener(eventType, callback);
        };
      },
      removeAllListeners() {
        for (const { target, eventType, callback } of listeners2) {
          target.removeEventListener(eventType, callback);
        }
        listeners2 = [];
      },
      once(eventType) {
        const bindings = [];
        return new Promise((resolve, reject) => {
          const handleIncomingMessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              if (message.type === eventType) {
                resolve(message);
              }
            } catch (error2) {
              reject(error2);
            }
          };
          bindings.push(context.events.addListener(navigator.serviceWorker, "message", handleIncomingMessage), context.events.addListener(navigator.serviceWorker, "messageerror", reject));
        }).finally(() => {
          bindings.forEach((unbind) => unbind());
        });
      }
    },
    useFallbackMode: !("serviceWorker" in navigator) || location.protocol === "file:"
  };
  const startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);
  const stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);
  return {
    start: prepareStartHandler(startHandler, context),
    stop() {
      context.events.removeAllListeners();
      context.emitter.removeAllListeners();
      publicEmitter.removeAllListeners();
      stopHandler();
    },
    use(...handlers2) {
      use(context.requestHandlers, ...handlers2);
    },
    restoreHandlers() {
      restoreHandlers(context.requestHandlers);
    },
    resetHandlers(...nextHandlers) {
      context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);
    },
    printHandlers() {
      context.requestHandlers.forEach((handler) => {
        const { header, callFrame } = handler.info;
        const pragma = handler.info.hasOwnProperty("operationType") ? "[graphql]" : "[rest]";
        console.groupCollapsed(`${pragma} ${header}`);
        if (callFrame) {
          console.log(`Declaration: ${callFrame}`);
        }
        console.log("Handler:", handler);
        if (handler instanceof RestHandler) {
          console.log("Match:", `https://mswjs.io/repl?path=${handler.info.path}`);
        }
        console.groupEnd();
      });
    },
    events: {
      on(...args) {
        return publicEmitter.on(...args);
      },
      removeListener(...args) {
        return publicEmitter.removeListener(...args);
      },
      removeAllListeners(...args) {
        return publicEmitter.removeAllListeners(...args);
      }
    }
  };
}

// node_modules/@uidotdev/react-query-api/dist/react-query-api.esm.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error2) {
    reject(error2);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var runtime_1 = createCommonjsModule(function(module) {
  var runtime = function(exports) {
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self2, context);
      return generator;
    }
    exports.wrap = wrap;
    function tryCatch2(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports.awrap = function(arg) {
      return { __await: arg };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch2(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function(error2) {
            return invoke("throw", error2, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
      }
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;
    exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0)
        PromiseImpl = Promise;
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self2, tryLocsList),
        PromiseImpl
      );
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self2, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch2(innerFn, self2, context);
          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        context.delegate = null;
        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method"
          );
        }
        return ContinueSentinel;
      }
      var record = tryCatch2(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }
      context.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    define(Gp, iteratorSymbol, function() {
      return this;
    });
    define(Gp, "toString", function() {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();
      return function next() {
        while (keys.length) {
          var key2 = keys.pop();
          if (key2 in object) {
            next.value = key2;
            next.done = false;
            return next;
          }
        }
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next2() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next2.value = iterable[i];
                next2.done = false;
                return next2;
              }
            }
            next2.value = undefined$1;
            next2.done = true;
            return next2;
          };
          return next.next = next;
        }
      }
      return { next: doneResult };
    }
    exports.values = values;
    function doneResult() {
      return { value: undefined$1, done: true };
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }
          return !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports;
  }(
    module.exports
  );
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
});
var users = [{
  id: "u_1",
  name: "Tyler",
  profilePictureUrl: "https://res.cloudinary.com/uidotdev/image/twitter_name/tylermcginnis"
}, {
  id: "u_2",
  name: "Bono",
  profilePictureUrl: "https://res.cloudinary.com/uidotdev/image/twitter_name/u2"
}, {
  id: "u_3",
  name: "Tanner",
  profilePictureUrl: "https://res.cloudinary.com/uidotdev/image/twitter_name/tannerlinsley"
}, {
  id: "u_4",
  name: "Alex",
  profilePictureUrl: "https://res.cloudinary.com/uidotdev/image/twitter_name/ralex1993"
}];
var labels = [{
  id: "bug",
  color: "red",
  name: "bug"
}, {
  id: "feature",
  color: "blue",
  name: "feature"
}, {
  id: "enhancement",
  color: "cyan",
  name: "enhancement"
}, {
  id: "question",
  color: "orange",
  name: "question"
}, {
  id: "help",
  color: "lime",
  name: "help wanted"
}, {
  id: "wontfix",
  color: "white",
  name: "wontfix"
}, {
  id: "duplicate",
  color: "rebeccapurple",
  name: "duplicate"
}];
var part1 = ["Dependencies", "The App", "Windows", "macOS", "Styling", "Button", "Target", "Input", "Field", "JavaScript", "React", "JQuery", "My Cookies"];
var part2 = ["is having a problem", "seems to struggle", "throws an error", "makes my computer run slow", "causes the processor to heat up", "looks weird", "cannot read property 'length' of undefined", "is not working", "is not responding", "is not working properly", "is not working as expected", "is crashing", "won't run right", "is actually working fine. I just wanted to let you know you're great"];
var part3 = ["when I rage click it", "on Tuesdays", "every time I wear my green shirt", "when I'm on a plane", "when I'm on a train", "when I'm on a boat", "when I'm on a bike", "right now", "all the time", "on weekends", "when I'm with Taylor Swift", "whenever I try to demo it"];
var templateIssueComments = ["I'm on it!", "I'm not sure what the problem is.", "I'm working on it.", "I'm not sure how to fix it.", "I'm not sure if I can reproduce the problem.", "This is a really big deal for me.", "Has there been any progress on this?", "What is the status of this issue?", "Never mind, I figured out how to fix this", "Can you send me a little bit more information about the problem.", "I've reproduced this issue. Working on a fix now.", "I'm on it. I'll get back to you when I'm done.", "It would seem this is caused by user error.", "Whoops, I just dropped the production database. Hang on..."];
var allStatus = ["backlog", "todo", "inProgress", "done", "cancelled"];
var issueComments = Array.from({
  length: 500
}, function(_, j) {
  return {
    id: "c_" + j,
    createdDate: new Date(Date.now() - Math.floor(Math.random() * 1e7)),
    createdBy: users[Math.floor(Math.random() * users.length)].id,
    comment: templateIssueComments[Math.floor(Math.random() * templateIssueComments.length)]
  };
}).sort(function(a, b) {
  if (a.createdDate < b.createdDate) {
    return -1;
  }
  if (a.createdDate > b.createdDate) {
    return 1;
  }
  return 0;
});
var issues = Array.from({
  length: 1e3
}, function(_, i) {
  var isCompleted = Math.random() > 0.9;
  var title = part1[Math.floor(Math.random() * part1.length)] + " " + part2[Math.floor(Math.random() * part2.length)] + " " + part3[Math.floor(Math.random() * part3.length)];
  return {
    id: "i_" + i,
    title,
    labels: [labels[Math.floor(Math.random() * labels.length)].id],
    comments: Array.from({
      length: Math.round(Math.random() * 500)
    }).map(function() {
      return "c_" + Math.round(Math.random() * 500);
    }).filter(function(a, i2, arr) {
      return arr.indexOf(a) === i2;
    }),
    number: i + 1,
    status: isCompleted ? "done" : allStatus.filter(function(f) {
      return f !== "done";
    })[Math.floor(Math.random() * allStatus.length)],
    createdDate: new Date(Date.now() - Math.floor(Math.random() * 1e7)),
    createdBy: users[Math.floor(Math.random() * users.length)].id,
    assignee: Math.random() > 0.5 ? users[Math.floor(Math.random() * users.length)].id : null,
    dueDate: Math.random() > 0.5 ? new Date(Date.now() + Math.floor(Math.random() * 1e7)) : null,
    completedDate: isCompleted ? new Date(Date.now() + Math.floor(Math.random() * 1e7)) : null
  };
});
var makeUrl = function makeUrl2(path) {
  return (typeof window === "undefined" ? "http://localhost:8000" : "") + path;
};
var handleErrorDelay = function() {
  var _ref = _asyncToGenerator(runtime_1.mark(function _callee(req) {
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!req.headers.get("x-delay")) {
              _context.next = 5;
              break;
            }
            _context.next = 3;
            return new Promise(function(resolve) {
              return setTimeout(resolve, Number(req.headers.get("x-delay")) || 0);
            });
          case 3:
            _context.next = 7;
            break;
          case 5:
            _context.next = 7;
            return new Promise(function(resolve) {
              return setTimeout(resolve, Math.random() * 500 + 500);
            });
          case 7:
            if (!req.headers.get("x-error")) {
              _context.next = 10;
              break;
            }
            if (!(Math.random() > 0.5)) {
              _context.next = 10;
              break;
            }
            throw new Error();
          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return function handleErrorDelay2(_x) {
    return _ref.apply(this, arguments);
  };
}();
var handlers = [rest.get(makeUrl("/api/status"), function() {
  var _ref2 = _asyncToGenerator(runtime_1.mark(function _callee2(_req, res, ctx) {
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", res(ctx.status(200), ctx.json({
              status: "ok"
            })));
          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return function(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}()), rest.get(makeUrl("/api/issues"), function() {
  var _ref3 = _asyncToGenerator(runtime_1.mark(function _callee3(req, res, ctx) {
    var query, page, perPage, statusFilter, labelQuery, order, filteredIssues, sortedIssues, pagedIssues;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context3.next = 8;
            break;
          case 5:
            _context3.prev = 5;
            _context3.t0 = _context3["catch"](0);
            return _context3.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            query = req.url.searchParams;
            page = Number(query.get("page")) || 1;
            perPage = Number(query.get("limit")) || 10;
            statusFilter = query.get("status");
            labelQuery = query.getAll("labels[]");
            order = query.get("order") || "desc";
            filteredIssues = issues.filter(function(issue) {
              if (statusFilter) {
                if (issue.status !== statusFilter)
                  return false;
              } else {
                if (issue.status === "done" || issue.status === "cancelled")
                  return false;
              }
              if (labelQuery.length > 0) {
                if (!labelQuery.some(function(label) {
                  var dbLabel = labels.find(function(l) {
                    return l.name === label;
                  });
                  if (!dbLabel)
                    return false;
                  return issue.labels.find(function(l) {
                    return l === dbLabel.id;
                  });
                })) {
                  return false;
                }
              }
              return true;
            });
            sortedIssues = filteredIssues.sort(function(a, b) {
              if (order === "asc") {
                if (a.number < b.number)
                  return -1;
                if (a.number > b.number)
                  return 1;
                return 0;
              } else {
                if (a.number < b.number)
                  return 1;
                if (a.number > b.number)
                  return -1;
                return 0;
              }
            });
            pagedIssues = sortedIssues.slice((page - 1) * perPage, page * perPage);
            return _context3.abrupt("return", res(ctx.status(200), ctx.json(pagedIssues)));
          case 18:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 5]]);
  }));
  return function(_x5, _x6, _x7) {
    return _ref3.apply(this, arguments);
  };
}()), rest.get(makeUrl("/api/issues/:number"), function() {
  var _ref4 = _asyncToGenerator(runtime_1.mark(function _callee4(req, res, ctx) {
    var number, issue;
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context4.next = 8;
            break;
          case 5:
            _context4.prev = 5;
            _context4.t0 = _context4["catch"](0);
            return _context4.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            number = Number(req.params.number);
            issue = issues.find(function(issue2) {
              return issue2.number === number;
            });
            if (issue) {
              _context4.next = 12;
              break;
            }
            return _context4.abrupt("return", res(ctx.status(404), ctx.json({
              message: "Not found"
            })));
          case 12:
            return _context4.abrupt("return", res(ctx.status(200), ctx.json(issue)));
          case 13:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 5]]);
  }));
  return function(_x8, _x9, _x10) {
    return _ref4.apply(this, arguments);
  };
}()), rest.get(makeUrl("/api/issues/:number/comments"), function() {
  var _ref5 = _asyncToGenerator(runtime_1.mark(function _callee5(req, res, ctx) {
    var number, issue, query, page, perPage, order, filteredComments, sortedIssues, pagedComments;
    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context5.next = 8;
            break;
          case 5:
            _context5.prev = 5;
            _context5.t0 = _context5["catch"](0);
            return _context5.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            number = Number(req.params.number);
            issue = issues.find(function(issue2) {
              return issue2.number === number;
            });
            if (issue) {
              _context5.next = 12;
              break;
            }
            return _context5.abrupt("return", res(ctx.status(404), ctx.json({
              message: "Not found"
            })));
          case 12:
            query = req.url.searchParams;
            page = Number(query.get("page")) || 1;
            perPage = Number(query.get("limit")) || 10;
            order = query.get("order") || "desc";
            filteredComments = issue.comments.map(function(id) {
              return issueComments.find(function(comment) {
                return comment.id === id;
              });
            }).filter(Boolean);
            sortedIssues = filteredComments.sort(function(a, b) {
              if (order === "asc") {
                if (a.createdDate < b.createdDate)
                  return -1;
                if (a.createdDate > b.createdDate)
                  return 1;
                return 0;
              } else {
                if (a.createdDate < b.createdDate)
                  return 1;
                if (a.createdDate > b.createdDate)
                  return -1;
                return 0;
              }
            });
            pagedComments = sortedIssues.slice((page - 1) * perPage, page * perPage);
            return _context5.abrupt("return", res(ctx.status(200), ctx.json(pagedComments)));
          case 20:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[0, 5]]);
  }));
  return function(_x11, _x12, _x13) {
    return _ref5.apply(this, arguments);
  };
}()), rest.post(makeUrl("/api/issues/:number/comments"), function() {
  var _ref6 = _asyncToGenerator(runtime_1.mark(function _callee6(req, res, ctx) {
    var number, issue, body2, createdBy, comment;
    return runtime_1.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            _context6.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context6.next = 8;
            break;
          case 5:
            _context6.prev = 5;
            _context6.t0 = _context6["catch"](0);
            return _context6.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            number = Number(req.params.number);
            issue = issues.find(function(issue2) {
              return issue2.number === number;
            });
            if (issue) {
              _context6.next = 12;
              break;
            }
            return _context6.abrupt("return", res(ctx.status(404), ctx.json({
              message: "Not found"
            })));
          case 12:
            body2 = JSON.parse(req.body);
            createdBy = users.find(function(user) {
              return user.id === body2.createdBy_id;
            });
            if (createdBy) {
              _context6.next = 16;
              break;
            }
            return _context6.abrupt("return", res(ctx.status(400), ctx.json({
              message: "Not found"
            })));
          case 16:
            comment = {
              id: "c_" + issue.id + "_" + (issue.comments.length + 1),
              createdDate: new Date(),
              createdBy: createdBy.id,
              comment: body2.comment
            };
            issue.comments.push();
            return _context6.abrupt("return", res(ctx.status(201), ctx.json(comment)));
          case 19:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[0, 5]]);
  }));
  return function(_x14, _x15, _x16) {
    return _ref6.apply(this, arguments);
  };
}()), rest.put(makeUrl("/api/issues/:number"), function() {
  var _ref7 = _asyncToGenerator(runtime_1.mark(function _callee7(req, res, ctx) {
    var number, issue, body2, _users$find;
    return runtime_1.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.prev = 0;
            _context7.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context7.next = 8;
            break;
          case 5:
            _context7.prev = 5;
            _context7.t0 = _context7["catch"](0);
            return _context7.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            number = Number(req.params.number);
            issue = issues.find(function(issue2) {
              return issue2.number === number;
            });
            if (issue) {
              _context7.next = 12;
              break;
            }
            return _context7.abrupt("return", res(ctx.status(404), ctx.json({
              message: "Not found"
            })));
          case 12:
            body2 = {};
            if (typeof req.body === "string")
              body2 = JSON.parse(req.body);
            if (typeof req.body === "object")
              body2 = req.body;
            if (body2.title) {
              issue.title = body2.title;
            }
            if (body2.status) {
              issue.status = body2.status;
            }
            if (body2.labels) {
              issue.labels = body2.labels.map(function(l) {
                var _labels$find;
                return (_labels$find = labels.find(function(lbl) {
                  return lbl.id === l;
                })) == null ? void 0 : _labels$find.id;
              }).filter(Boolean);
            }
            if (body2.dueDate) {
              issue.dueDate = body2.dueDate;
            }
            if (body2.assignee) {
              issue.assignee = ((_users$find = users.find(function(user) {
                return user.id === body2.assignee;
              })) == null ? void 0 : _users$find.id) || null;
            }
            return _context7.abrupt("return", res(ctx.status(200), ctx.json(issue)));
          case 21:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, null, [[0, 5]]);
  }));
  return function(_x17, _x18, _x19) {
    return _ref7.apply(this, arguments);
  };
}()), rest.post(makeUrl("/api/issues/:number/complete"), function() {
  var _ref8 = _asyncToGenerator(runtime_1.mark(function _callee8(req, res, ctx) {
    var number, issue;
    return runtime_1.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            _context8.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context8.next = 8;
            break;
          case 5:
            _context8.prev = 5;
            _context8.t0 = _context8["catch"](0);
            return _context8.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            number = Number(req.params.number);
            issue = issues.find(function(issue2) {
              return issue2.number === number;
            });
            if (issue) {
              _context8.next = 12;
              break;
            }
            return _context8.abrupt("return", res(ctx.status(404), ctx.json({
              message: "Not found"
            })));
          case 12:
            issue.createdDate = new Date();
            issue.status = "done";
            return _context8.abrupt("return", res(ctx.status(200), ctx.json(issue)));
          case 15:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, null, [[0, 5]]);
  }));
  return function(_x20, _x21, _x22) {
    return _ref8.apply(this, arguments);
  };
}()), rest.post(makeUrl("/api/issues"), function() {
  var _ref9 = _asyncToGenerator(runtime_1.mark(function _callee9(req, res, ctx) {
    var body2, number, issueComment, issue;
    return runtime_1.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.prev = 0;
            _context9.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context9.next = 8;
            break;
          case 5:
            _context9.prev = 5;
            _context9.t0 = _context9["catch"](0);
            return _context9.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            body2 = {};
            if (typeof req.body === "string")
              body2 = JSON.parse(req.body);
            if (typeof req.body === "object")
              body2 = req.body;
            number = issues.length + 1;
            issueComment = {
              issueId: "i_" + number,
              id: "c_" + issueComments.length,
              createdDate: new Date(),
              createdBy: users[Math.floor(Math.random() * users.length)].id,
              comment: body2.comment
            };
            issueComments.push(issueComment);
            issue = {
              id: "i_" + number,
              number,
              title: body2.title,
              status: "backlog",
              comments: [issueComment.id],
              createdDate: new Date(),
              createdBy: users[Math.floor(Math.random() * users.length)].id,
              dueDate: null,
              completedDate: null,
              assignee: null,
              labels: []
            };
            issues.push(issue);
            return _context9.abrupt("return", res(ctx.status(201), ctx.json(issue)));
          case 17:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, null, [[0, 5]]);
  }));
  return function(_x23, _x24, _x25) {
    return _ref9.apply(this, arguments);
  };
}()), rest.get(makeUrl("/api/labels"), function() {
  var _ref10 = _asyncToGenerator(runtime_1.mark(function _callee10(req, res, ctx) {
    return runtime_1.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.prev = 0;
            _context10.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context10.next = 8;
            break;
          case 5:
            _context10.prev = 5;
            _context10.t0 = _context10["catch"](0);
            return _context10.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            return _context10.abrupt("return", res(ctx.status(200), ctx.json(labels)));
          case 9:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, null, [[0, 5]]);
  }));
  return function(_x26, _x27, _x28) {
    return _ref10.apply(this, arguments);
  };
}()), rest.get(makeUrl("/api/labels/:labelId"), function() {
  var _ref11 = _asyncToGenerator(runtime_1.mark(function _callee11(req, res, ctx) {
    var labelId, label;
    return runtime_1.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.prev = 0;
            _context11.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context11.next = 8;
            break;
          case 5:
            _context11.prev = 5;
            _context11.t0 = _context11["catch"](0);
            return _context11.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            labelId = req.params.labelId;
            label = labels.find(function(l) {
              return l.name === labelId;
            });
            if (label) {
              _context11.next = 12;
              break;
            }
            return _context11.abrupt("return", res(ctx.status(404), ctx.json({
              message: "Label not found"
            })));
          case 12:
            return _context11.abrupt("return", res(ctx.status(200), ctx.json(label)));
          case 13:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11, null, [[0, 5]]);
  }));
  return function(_x29, _x30, _x31) {
    return _ref11.apply(this, arguments);
  };
}()), rest.post(makeUrl("/api/labels"), function() {
  var _ref12 = _asyncToGenerator(runtime_1.mark(function _callee12(req, res, ctx) {
    var body2, label;
    return runtime_1.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            _context12.prev = 0;
            _context12.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context12.next = 8;
            break;
          case 5:
            _context12.prev = 5;
            _context12.t0 = _context12["catch"](0);
            return _context12.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            body2 = {};
            if (typeof req.body === "string")
              body2 = JSON.parse(req.body);
            if (typeof req.body === "object")
              body2 = req.body;
            if (body2.name) {
              _context12.next = 13;
              break;
            }
            return _context12.abrupt("return", res(ctx.status(400), ctx.json({
              message: "No name"
            })));
          case 13:
            if (!labels.find(function(l) {
              return l.name === body2.name;
            })) {
              _context12.next = 15;
              break;
            }
            return _context12.abrupt("return", res(ctx.status(400), ctx.json({
              message: "Label already exists"
            })));
          case 15:
            label = {
              id: body2.name,
              name: body2.name,
              color: body2.color || "red"
            };
            labels.push(label);
            return _context12.abrupt("return", res(ctx.status(200), ctx.json(label)));
          case 18:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12, null, [[0, 5]]);
  }));
  return function(_x32, _x33, _x34) {
    return _ref12.apply(this, arguments);
  };
}()), rest.put(makeUrl("/api/labels/:labelId"), function() {
  var _ref13 = _asyncToGenerator(runtime_1.mark(function _callee13(req, res, ctx) {
    var labelId, label, body2;
    return runtime_1.wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            _context13.prev = 0;
            _context13.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context13.next = 8;
            break;
          case 5:
            _context13.prev = 5;
            _context13.t0 = _context13["catch"](0);
            return _context13.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            labelId = req.params.labelId;
            label = labels.find(function(l) {
              return l.name === labelId;
            });
            if (label) {
              _context13.next = 12;
              break;
            }
            return _context13.abrupt("return", res(ctx.status(404), ctx.json({
              message: "Label not found"
            })));
          case 12:
            body2 = {};
            if (typeof req.body === "string")
              body2 = JSON.parse(req.body);
            if (typeof req.body === "object")
              body2 = req.body;
            if (body2.name) {
              _context13.next = 17;
              break;
            }
            return _context13.abrupt("return", res(ctx.status(400), ctx.json({
              message: "No name"
            })));
          case 17:
            if (body2.name) {
              label.name = body2.name;
            }
            if (body2.color) {
              label.color = body2.color;
            }
            return _context13.abrupt("return", res(ctx.status(200), ctx.json(label)));
          case 20:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee13, null, [[0, 5]]);
  }));
  return function(_x35, _x36, _x37) {
    return _ref13.apply(this, arguments);
  };
}()), rest["delete"](makeUrl("/api/labels/:labelId"), function() {
  var _ref14 = _asyncToGenerator(runtime_1.mark(function _callee14(req, res, ctx) {
    var labelId, label;
    return runtime_1.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            _context14.prev = 0;
            _context14.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context14.next = 8;
            break;
          case 5:
            _context14.prev = 5;
            _context14.t0 = _context14["catch"](0);
            return _context14.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            labelId = req.params.labelId;
            label = labels.find(function(l) {
              return l.name === labelId;
            });
            if (label) {
              _context14.next = 12;
              break;
            }
            return _context14.abrupt("return", res(ctx.status(404), ctx.json({
              message: "Label not found"
            })));
          case 12:
            labels.splice(labels.indexOf(label), 1);
            return _context14.abrupt("return", res(ctx.status(200), ctx.json(labels)));
          case 14:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14, null, [[0, 5]]);
  }));
  return function(_x38, _x39, _x40) {
    return _ref14.apply(this, arguments);
  };
}()), rest.get(makeUrl("/api/users"), function() {
  var _ref15 = _asyncToGenerator(runtime_1.mark(function _callee15(req, res, ctx) {
    return runtime_1.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            _context15.prev = 0;
            _context15.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context15.next = 8;
            break;
          case 5:
            _context15.prev = 5;
            _context15.t0 = _context15["catch"](0);
            return _context15.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            return _context15.abrupt("return", res(ctx.status(200), ctx.json(users)));
          case 9:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15, null, [[0, 5]]);
  }));
  return function(_x41, _x42, _x43) {
    return _ref15.apply(this, arguments);
  };
}()), rest.get(makeUrl("/api/users/:userId"), function() {
  var _ref16 = _asyncToGenerator(runtime_1.mark(function _callee16(req, res, ctx) {
    var userId, user;
    return runtime_1.wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            _context16.prev = 0;
            _context16.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context16.next = 8;
            break;
          case 5:
            _context16.prev = 5;
            _context16.t0 = _context16["catch"](0);
            return _context16.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            userId = req.params.userId;
            user = users.find(function(l) {
              return l.id === userId;
            });
            if (user) {
              _context16.next = 12;
              break;
            }
            return _context16.abrupt("return", res(ctx.status(404), ctx.json({
              message: "User not found"
            })));
          case 12:
            return _context16.abrupt("return", res(ctx.status(200), ctx.json(user)));
          case 13:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16, null, [[0, 5]]);
  }));
  return function(_x44, _x45, _x46) {
    return _ref16.apply(this, arguments);
  };
}()), rest.get(makeUrl("/api/search/issues"), function() {
  var _ref17 = _asyncToGenerator(runtime_1.mark(function _callee17(req, res, ctx) {
    var query, filteredList;
    return runtime_1.wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            _context17.prev = 0;
            _context17.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context17.next = 8;
            break;
          case 5:
            _context17.prev = 5;
            _context17.t0 = _context17["catch"](0);
            return _context17.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            query = req.url.searchParams.get("q") || "";
            if (query) {
              _context17.next = 11;
              break;
            }
            return _context17.abrupt("return", res(ctx.status(401), ctx.json({
              message: "Search query is required"
            })));
          case 11:
            filteredList = issues.filter(function(issue) {
              return issue.title.includes(query);
            });
            return _context17.abrupt("return", res(ctx.status(200), ctx.json({
              count: filteredList.length,
              items: filteredList
            })));
          case 13:
          case "end":
            return _context17.stop();
        }
      }
    }, _callee17, null, [[0, 5]]);
  }));
  return function(_x47, _x48, _x49) {
    return _ref17.apply(this, arguments);
  };
}()), rest.get(makeUrl("/api/search/labels"), function() {
  var _ref18 = _asyncToGenerator(runtime_1.mark(function _callee18(req, res, ctx) {
    var query, filteredList;
    return runtime_1.wrap(function _callee18$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            _context18.prev = 0;
            _context18.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context18.next = 8;
            break;
          case 5:
            _context18.prev = 5;
            _context18.t0 = _context18["catch"](0);
            return _context18.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            query = req.url.searchParams.get("q") || "";
            if (query) {
              _context18.next = 11;
              break;
            }
            return _context18.abrupt("return", res(ctx.status(401), ctx.json({
              message: "Search query is required"
            })));
          case 11:
            filteredList = labels.filter(function(label) {
              return label.name.includes(query);
            });
            return _context18.abrupt("return", res(ctx.status(200), ctx.json({
              count: filteredList.length,
              items: filteredList
            })));
          case 13:
          case "end":
            return _context18.stop();
        }
      }
    }, _callee18, null, [[0, 5]]);
  }));
  return function(_x50, _x51, _x52) {
    return _ref18.apply(this, arguments);
  };
}()), rest.get(makeUrl("/api/search/comments"), function() {
  var _ref19 = _asyncToGenerator(runtime_1.mark(function _callee19(req, res, ctx) {
    var query, filteredList;
    return runtime_1.wrap(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            _context19.prev = 0;
            _context19.next = 3;
            return handleErrorDelay(req);
          case 3:
            _context19.next = 8;
            break;
          case 5:
            _context19.prev = 5;
            _context19.t0 = _context19["catch"](0);
            return _context19.abrupt("return", res(ctx.status(500), ctx.json({
              error: "Error in request"
            })));
          case 8:
            query = req.url.searchParams.get("q") || "";
            if (query) {
              _context19.next = 11;
              break;
            }
            return _context19.abrupt("return", res(ctx.status(401), ctx.json({
              message: "Search query is required"
            })));
          case 11:
            filteredList = issueComments.filter(function(comment) {
              return comment.comment.includes(query);
            });
            return _context19.abrupt("return", res(ctx.status(200), ctx.json({
              count: filteredList.length,
              items: filteredList
            })));
          case 13:
          case "end":
            return _context19.stop();
        }
      }
    }, _callee19, null, [[0, 5]]);
  }));
  return function(_x53, _x54, _x55) {
    return _ref19.apply(this, arguments);
  };
}())];
var worker = setupWorker.apply(void 0, handlers);
var wait = function wait2(ms) {
  return new Promise(function(res) {
    return setTimeout(res, ms);
  });
};
var callWithRetry = function() {
  var _ref = _asyncToGenerator(runtime_1.mark(function _callee(fn, depth) {
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (depth === void 0) {
              depth = 0;
            }
            _context.prev = 1;
            _context.next = 4;
            return fn();
          case 4:
            return _context.abrupt("return", _context.sent);
          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](1);
            if (!(depth > 7)) {
              _context.next = 11;
              break;
            }
            throw _context.t0;
          case 11:
            _context.next = 13;
            return wait(Math.pow(2, depth) * 10);
          case 13:
            return _context.abrupt("return", callWithRetry(fn, depth + 1));
          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 7]]);
  }));
  return function callWithRetry2(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var startWorker = function() {
  var _ref2 = _asyncToGenerator(runtime_1.mark(function _callee3() {
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return callWithRetry(function() {
              var _startWorker = _asyncToGenerator(runtime_1.mark(function _callee2() {
                var response2, data2;
                return runtime_1.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        worker.start();
                        _context2.next = 3;
                        return wait(100);
                      case 3:
                        _context2.next = 5;
                        return fetch("/api/status");
                      case 5:
                        response2 = _context2.sent;
                        _context2.next = 8;
                        return response2.json();
                      case 8:
                        data2 = _context2.sent;
                        if (!(data2.status !== "ok")) {
                          _context2.next = 11;
                          break;
                        }
                        throw new Error();
                      case 11:
                        return _context2.abrupt("return");
                      case 12:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));
              function startWorker2() {
                return _startWorker.apply(this, arguments);
              }
              return startWorker2;
            }());
          case 2:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return function startWorker2() {
    return _ref2.apply(this, arguments);
  };
}();
export {
  startWorker,
  worker
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=@uidotdev_react-query-api.js.map
